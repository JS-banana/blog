---
title: 【前端组件化】monorepo方案分析
date: 2022-08-18 11:14:47
permalink: /pages/af5c63/
categories:
  - 文章
  - 前端
tags:
  - monorepo
---

> 前端组件化系列文章 第二篇

## 前言

本篇内容主要围绕前端组件化一阶段的前期技术调研，关注到的一些相关技术栈及工具库，进行相关工具的测试和使用功能比对。

主要目的是为了在了解其功能的情况下熟悉其用法，加深对其功能特点的理解，以及在真实场景中的具体使用方式，是否符合本项目计划特点，包括对其优点和缺陷的梳理分析。

<!-- more -->

## 介绍

集中关注的技术点有：

- lerna
- changeset
- yarn + workspace + lerna
- pnpm + workspace + changeset / lerna
- webpack / rollup / gulp

## lernajs 的基本用法

常用命令如下：

1. lerna init：初始化项目 `npx lerna init`，independent 模式需要添加 `--independent`/`-i`

   ```js
   // 会生成如下目录
   lerna - example / packages / package.json
   lerna.json
   ```

2. lerna create：创建一个新的包 `lerna create animal`

   ```js
   // 会包含基本的文件
   └── packages
     ├── animal
     │   ├── README.md
     │   ├── __tests__
     │   │   └── animal.test.js
     │   ├── lib
     │   │   └── animal.js
     │   └── package.json
     └── dog
         ├── README.md
         ├── __tests__
         │   └── dog.test.js
         ├── lib
         │   └── dog.js
         └── package.json
   ```

3. lerna add：添加本地包或者远程包作为包的依赖

   ```sh
   # 向名字以 prefix- 为前缀的文件夹里面添加 module-1 作为依赖
   $ lerna add module-1 packages/prefix-*

   # 向 module-2 中添加 module-1 作为依赖
   $ lerna add module-1 --scope=module-2

   # 向 module-2 中添加 module-1 作为开发依赖（devDependencies）
   $ lerna add module-1 --scope=module-2 --dev

   # 向 module-2 中添加 module-1 作为peerDependencies
   $ lerna add module-1 --scope=module-2 --peer

   # 向除了module-1（因为 module-1 是本地包）的所有包中添加 module-1 作为依赖
   $ lerna add module-1

   # 向所有的包中添加 babel-core 作为依赖（ babel-core 是远程包）
   $ lerna add babel-core
   ```

4. lerna version：发布前更新包的版本 （lerna publish 包含这一步）

   ```sh
   lerna version 1.0.1 # 直接指定特定的版本
   lerna version patch # 使用语义关键字
   lerna version       # 通过交互式命令选择
   ```

   lerna version 在背后为我们做了这些事：

   - 识别出自上次发布以后更新过的包；
   - 提示选择新版本；
   - 修改包的元数据来反映最新发版（修改包的版本号），在根目录和每个包里面运行生命周期脚本；
   - 对提交打 tag；
   - 推送到远程代码仓库。

5. lerna publish：布本地包，发布自上次发布过后更新过的包（背后会执行 lerna version）

   ```sh
   #发布自上次发布过后更新过的包 （背后会执行 lerna version）
   $ lerna publish
   #发布当前通过 lerna version 打好 tag 的包，需要先使用 lerna version 更新版本
   $ lerna publish from-git
   #只发布远程 npm 仓库中没有的版本，适用于 lerna publish 没有全部发布成功的场景。
   $ lerna publish from-package
   ```

6. lerna list：列出所有的本地包

   ```sh
   $ lerna list
   lerna notice cli v5.3.0
   lerna info versioning independent
   animal
   dog
   lerna success found 2 packages
   ```

7. lerna info：打印出本地环境信息

8. lerna changed：列出自上一次发布过后修改过的包

9. lerna clean：移除所有 package 下的 node_modules，除了根目录下的 node_modules

10. lerna bootstrap：建立相互依赖的包之间的软连接并安装其他的依赖

    这个命令在背后执行了以下步骤:

    - 安装所有包的外部依赖
    - 建立存在依赖关系的包之间的依赖
    - 在 bootstrapped 的包中执行 npm run prepublish （没有指定 --ignore-prepublish 的情况下）
    - 在 bootstrapped 的包中执行 npm run prepare

11. lerna diff：列出包自上一次发版以来做出的修改。

    ```sh
    # 列出所有包的改动
    $ lerna diff
    # 列出具体某个包的改动
    $ lerna diff package-name
    ```

12. lerna exec：使用 lerna exec 可以在所有的包目录下执行任意的命令。

    ```sh
    lerna exec -- <command> [..args] # runs the command in all packages
    lerna exec -- rm -rf ./node_modules # 删除所有包下面的 node_modules
    ```

13. lerna run：使用 lerna run 可以在所有的包目录下执行对应的脚本。

14. lerna import：将已经存在的项目作为一个包导入到现有的 lerna 项目中，同时项目的 commit 历史记录会被一并导入。

    ```sh
    lerna import <path-to-external-repository>
    ```

15. lerna link：建立存在依赖关系的包之间的软连接

    ```sh
    lerna link
    ```

## pnpm + workspace 的基本用法

### 简单介绍

pnpm 官方介绍（文档）：<https://pnpm.io/zh/motivation>

pnpm 内置了对单一存储库（也称为多包存储库、多项目存储库或单体存储库）的支持， 你可以创建一个 workspace（工作空间） 以将多个项目合并到一个仓库中。

一个 workspace 的根目录下必须有 `pnpm-workspace.yaml` 文件， 也可能会有 `.npmrc` 文件。

peerDependencies：

- npm：自动安装 peers
- yarn：否
- pnpm：通过 auto-install-peers=true 开启

如何使用？

直接通过 npm 安装：`npm install -g pnpm`

版本要求：

6.x => node 12
7.x => node 14

### 关键参数

| npm 命令        | pnpm 等效      |
| --------------- | -------------- |
| `npm install`   | `pnpm install` |
| `npm i <pkg>`   | `pnpm i <pkg>` |
| `npm run <cmd>` | `pnpm <cmd>`   |

**全局命令**

- `--filter`：过滤，过滤允许您将命令限制于包的特定子集，一般用于 packages/\* 下面的子项目。

  ```sh
  pnpm i dayjs -r --filter @jack/web
  ```

- `-C`：在 `<path>` 中启动 pnpm ，而不是当前的工作目录。

  ```sh
  # 运行项目下的 docs 目录中的 dev
  pnpm run -C docs dev
  ```

- `-w`（`--workspace-root`）：在工作空间的根目录中启动 pnpm ，而不是当前的工作目录。

  ```sh
  # vue依赖作为全局安装在根目录中
  pnpm i vue -w
  # 开发依赖 -D
  pnpm i eslint -Dw
  ```

**pnpm install**

在 workspace 内, pnpm install 下载项目所有依赖. 如果想禁用这个行为, 将 `recursive-install` 设置为 `false`。

`--shamefully-hoist`：创建一个扁平 node_modules 目录结构, 类似于 npm 或 yarn. 一般配置在`.npmrc`中。

- 安装依赖

  - `-w`：表示把包安装在 root 下，该包会放置在 `<root>/node_modules` 下
  - `-r`：安装在所有 packages 中（一般配合`--filter`指定项目目录）

    ```sh
    # 用 pnpm 安装全局共用的包
    pnpm install vue -w
    # 只安装在 packages/web 目录中，其package.json中的name为 @jack/web
    pnpm i dayjs -r --filter @jack/web
    ```

    如 vue 这样多个子项目都需要使用的包，可以安装到全局。

**pnpm run**

- `-r`：针对每个 package.json script 对象中执行对应的命令，没有匹配到则跳过。
- `--parallel`：忽略并发，立即在所有匹配的软件包中运行一个给定的脚本，用于在许多 packages 上长时间运行的进程，例如冗长的构建进程。
- `--stream`：以起始 package 目录作为前缀，立即从子进程输出流。 这允许从不同的 package 交替输出。

  ```sh
  # 执行每个子项目的 clean 命令
  # 清理 packages 下面所有子项目
  pnpm run -r --parallel clean
  ```

## changeset基本使用

1. **changeset init**

   - 新项目执行该命令，完成对项目的初始化
   - 会在根目录下生成 `.changeset` 目录，`config.json`配置文件

2. **changeset**

   - 执行该命令，进行版本管理，会交互式选择不同项目，以及确定发布的版本
   - 会生成一些 `.md` 文件在目录下，会在 `version` 的时候消耗

3. **changeset version**

   - 消耗上一步生成的相关的一些版本信息及记录内容的 `.md` 文件，并生成或更新 `CHANGELOG.md` 文件，之后 `.md` 文件会被自动删除
   - 相应的 `package.json` 中的 `version` 信息也会同步更新

4. **changeset publish**

   - 发布包到远程 `npm` 源
   - 前置条件是你已经进行了 `npm` 账户登录，如果包名称为 `@ah-ailpha/components`该类型，还需要在 npm 账户中设置组织
