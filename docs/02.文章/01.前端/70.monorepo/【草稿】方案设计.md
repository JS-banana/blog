---
title: 【前端组件化】pnpm + monorepo + changeset 的方案设计
date: 2022-08-18 15:11:22
permalink: /pages/23154c/
article: false
categories:
  - 文章
  - 前端
tags:
  - monorepo
---

> 前端组件化系列文章 第三篇

## 前言

对于我为何最终选择了使用 `pnpm + workspace` 的 **monorepo**方案？

坦诚的说，我第一选择的方案是 `yarn + lerna`，但是在使用测试的过程中，我发现 `yarn` 和 `lerna`的一些弊端都是极其明显的，首先对于 `yarn`，它的功能相对于`pnpm`是有一些缺失的，而这一部分又是我比较需要的，其次对于`lerna`的使用感觉也是比较奇怪，有些功能感觉也是`pnpm`包含的，而只针对版本管理而言lerna也有一些不符合预期的问题。

再结合了一些市场调研后，综合性能和使用上的考虑，还是以 `pnpm + workspace`的方案更为占优，就实际情况而言也确实符合预期。

<!-- more -->

## 基本目标

1. 友好的项目设计、较低的上手门槛
2. 易于维护和调试的独立方案
3. 规范化的项目工程化管理
4. 详细和功能完备的文档网站
5. 优雅的包管理方案
6. 测试

## 目标拆解

### 1. 友好的项目设计、较低的上手门槛

常规套路，我们接手一个新的仓库代码，首先，要了解仓库的相关依赖、目录结构、规范、开发逻辑等，之后的开发人员便按照此逻辑进行开发和迭代。

好的设计能够让我们快速的介入进来，无感的进行核心功能的开发，不受其项目影响。而相对的，不清晰的目录划分和无规则的逻辑会极大的增加我们的上手成本，包括日后的可维护性都会大打折扣。

因此，该设计应该能显著减少我们的上手成本，并降低我们对这些代码之外的关注点的投入。

1. 新人可以快速上手，学习门槛较低。通过简单的介绍就能够理解本项目的开发范式，并可快速投入开发。
2. 有着合理、清晰的文件目录划分，整个项目有着清晰的结构。目录的设计和功能息息相关，便于维护，并能够围绕目录结构设计做到一些功能的脚本自动化处理。

### 2. 易于维护和调试的独立方案

如何理解维护？我觉得抛开项目创建者，参与进来的其他开发人员或多或少都和维护角色有点关系。特别针对后期加入进来的开发人员而言，对于某一功能的迭代、优化、开发新特性等。

如何做到快速参与进来，接手和维护之前的功能代码呢?这一点至关重要。

1. 清晰的注释。包括但不限于一些 API 的说明，方法、属性的介绍。
2. 合理的拆分和目录划分。功能代码、逻辑代码、业务代码、工具代码应该有比较清晰的划分。如：相关常量定义、json 配置相关代码。
3. 各组件应相对独立。在项目中的目录相对独立、在开发调试能够一定程度的相对独立、单一组件可以独立开发维护，以及在最终使用引入时。

### 3. 规范化的项目工程化管理

首先，在能够强制保证的条件下采用 `eslint` 等规范做到主要规范控制，配合 vscode 等工具链做到工程化方面的约束。

其次，在不能具体由工程化方面控制的地方，做到统一约束，包括目录结构的设计等，并输出规范文档，确保足够清晰简单，方便新人执行。

1. `eslint` + `prettier` + `commitlint` （`editorconfig`）。在工程化方面保证相关规范强制执行。
2. 结合目录划分结构，按照设计规划规范执行相关准则，做到统一约束。如 **monorepo** 多包管理方案，及开源社区的最佳实践等（`element-plus`、`tdesign-vue`、`ant-design-vue` 等）。
3. 并基于第 2 点此约束条件，产出部分自动化脚本工具，包括但不限于`路由生成`、`源码展示`、`demo 演示`、`npm 发布处理`等。
4. 视情况建议在项目层面做到 `TypeScript` 的支持，做到脚本代码层面的一定约束。

### 4. 详细和功能完备的文档网站

文档网站——其功能性和重要性不言而喻，主要作为第一入口提供给用户，作为了解本项目的第一途径。

1. 第一要素：基本内容应包含，使用指南，组件 API、属性、方法等相关介绍说明等。
2. 第二点：使用方式和用法展示。真实渲染环境展示效果，相关代码使用展示（`demo` / `code`）。
3. 在项目代码层面可能会涉及到与约定目录的自动化脚本生成相关，进而快速自动实现如：路由、API 等相关功能。

### 5. 优雅的包管理方案

1. 最大限度的精简每个组件的引入加载代码。如：按需加载时，只加载自身相关代码。
2. 使用 **monorepo** 多包管理方案，更好的管理不同组件、工具、库的代码，统一管理 npm 发包。
3. 按组件能力划分基础 UI 组件和高级组件。基础组件采用 `iview` 等 UI 库的方案，整体维护，支持按需加载。高级组件独立维护，采用单独发包的方案，最大程度的做到独立，更好的维护。

### 6. 测试

1. 最基本的手动功能测试和逻辑测试，本项目提供一个 `examples` 目录用于模拟真实场景，来测试组件。
2. 标准化、自动化脚本测试的方案，如：`test/crypass`，不过该方案需要前期投入成本，结合实际情况本项目暂不考虑。

## 方案梳理

1. 命名规范

   - 首要原则，保持命名空间唯一性，命名规范应该符合本项目整体风格，如：按照以`Ah`为前缀的形式，对组件名称进行拼接。
   - 组件目录小写命名：为了符合 `package.json` 包名的命名规则，以及在项目中保持目录名称统一，组件目录以小写字母为标准，不支持大写字母。（`pro-sqltiptree`）
   - 组件导入导出首字母大写：作为组件，按照标准化方案，导出时和引入时，应该按照首字母大写的形式，并以驼峰式写法。（`ProSqlTipTree`）
   - 工具类的相关函数名称：应该以小写字母开头，按照驼峰式名称规范，并保证具有一定的语义化。（`getSortListById`）
   - 常量类：全大写，并以下划线拼接。（`BUTTON_TYPE`）

   > 组件名称
   >
   > 1. 目录规范按照正常小写定义：`button`，目录结构见下面第三点
   >
   > 2. vue 组件命名空间 name 为：`AhButton`
   >
   > 3. 使用时按照 vue 连字符形式：`<ah-button />`

   ```js
   // 组件Button
   export default {
       name: 'AhButton',
   }
   // 组件AhProSqlTipTree
   export default {
       name: 'AhProSqlTipTree',
   }
   ```

2. 采用 monorepo 方案，更好的版本管理，相关源码统一在 packages/\* 下面维护，可以实现每个文件目录作为一个 npm 包发布使用。

   ```js
   ├── packages                           // packages工作目录
       ├── utils                          // 工具库
       ├── pro-sqltiptree                 // 高级组件之一，独单作为一个npm包
       ├── components                     // 基础组件，整体作为一个npm包，内部组件按需加载使用
           ├── select                     // 基础组件之一 Select，
           ├── ...
   ```

   ```js
   // 用法示例
   import { Select } from '@ah-ailpha/components'
   import ProSqlTipTree from '@ah-ailpha/pro-sqltiptree'
   ```

3. 目录划分设计，唯一出入口，职责分明。源码文件、demo 文件、文档

   ```js
   ├── examples                   // 演示目录，用于调试代码
   ├── docs                       // 文档目录，用于编写对应组件的相关文档，以及文档网站的建设配置
   ├── packages                   // packages工作目录
       ├── components             // 子项目之一 => 组件目录
   ```

   ```js
   // 基础组件示例
   ├── select                         // Select组件的开发目录
       // ├── __tests__               // 测试相关
       ├── style                      // 组件相关样式代码
       // ├── demo                    // demo演示源码目录，这里会配合开发工具和脚本实现渲染展示
       // ├── docs                    // docs文档说明
       ├── src                        // 组件源码目录
           ├── index.vue              // 组件源码
           ├── props.js               // props相关定义的声明
           ├── const.js               // 常量
       ├── index.js                   // 统一出入口
   ```

   ```js
   // 高级组件示例
   ├── packages                           // packages工作目录
       ├── pro-sqltiptree                 // 高级组件之一，独单作为一个npm包
           // ├── __tests__               // 测试相关
           // ├── examples                // 演示网站
           ├── style                      // 组件相关样式代码
           // ├── demo                    // demo演示源码目录，这里会配合开发工具和脚本实现渲染展示
           // ├── docs                    // docs文档说明
           ├── src                        // 组件源码目录
               ├── index.vue             // 组件源码
               ├── props.js               // props相关定义的声明
               ├── const.js               // 常量
           ├── index.js                   // 统一出入口
           ├── package.json               // package.json 文件
   ```

   ```js
   ├── docs
       ├── components                  // 基础组件文档目录
           ├── button.md               // button 组件相关文档
           ├── select.md               // select 组件相关文档
       ├── pro-components              // 高级组件文档目录
           ├── sqltiptree.md           // sqltiptree 组件相关文档
   ```

4. 开发调试和编译打包

   - 基于公司项目背景考虑，目前组件的构建工具主要还是 `Webpack` 方案，求稳，兼容老旧的方案
   - 工具类的构建打包使用 `TypeScript` + `Rollup`的方案
   - 为了模拟真实环境，提供 `examples`目录进行开发调试
   - 在打包构建层面做到绝对的依赖拆分，组件分离，支持按需加载

5. 版本管理和包发布

   - 使用 **changeset**进行多包版本管理
   - 交互式CLI确定包版本 => 生成相应 `CHANGELOG.md`日志，并更新 `package.json` `version`信息
   - 发布包至`npm`

6. 工程化规范

   - 使用 husky/pre-commit + lint-staged + eslint + prettier + markdownlint 约束代码规范

## 开发规划

基于开发时间考虑，目前规划如下

### 当前

本项目主要结合实际业务场景积淀，产出各不同使用场景的组件。目前主要分为原始 UI 组件、基础组件、高级业务组件。

- **原始 UI 组件**：主要为开源第三方 UI 组件，该项目为 iview，在此基础上会做一些符合本公司业务主题风格的调整，但基本逻辑应保持原有不变。
- **基础组件**：指在 UI 组件之上改造和迭代了一些功能逻辑，或基于 vue 自行开发的组件。这里的定义应该是在依赖中应该只涉及到`vue`、`iview`等依赖。
- **高级组件**：大部分是具有高度限定使用场景的业务组件，以及涉及到基础组件的复杂功能封装，或基于其他第三方依赖库进行的二次封装开发。其特征应该是涉及核心依赖之外又包括多个其他依赖的，具有一定的相对独立性，可以且适合单独进行维护的一些组件。这类组件只在需要时进行安装使用。

目前项目设计为文档、调试、开发三者分离

- `docs` 目前负责文档相关的编写，包括最终的文档网站生成
- `examples` 负责组件功能调试，模拟真实开发环境
- `packages` 下不同子项目进行对应功能开发

因此，当你开发一个组件时，源码文件应该在 `packages` 下指定的一个文件目录中进行，而相关组件的文档应该在根目录下的 `docs` 目录下进行维护，以及项目 `demo` 应该在 `examples` 下面进行维护，需要说明的是，这三个目录中的文件命名和结构应该符合规范，做到彼此对应。

```js
├── examples                        // 演示目录，用于调试代码
    ├── src                         //
        ├── demos                   // demo 目录
            ├── pro-sqltiptree      // pro-sqltiptree组件的项目demo用例
                ├── base.vue        // 基础用法
                ├── ...             // 其他各种不同使用方式用法示例
                ├── index.vue       // 统一入口
├── docs                            // 文档目录，用于编写对应组件的相关文档，以及文档网站的建设配置
    ├── pro-components              // 高级组件文档目录
        ├── pro-sqltiptree.md       // pro-sqltiptree高级组件的相关文档
    ├── .vuepress                   // docs的项目配置目录
        ├── nav.js                  // docs的菜单配置，需要配置相关菜单
├── packages                        // packages工作目录
        ├── pro-sqltiptree          // pro-sqltiptree高级组件的开发目录
            ├── src                 //
                ├── style           //
                ├── index.vue       // 组件源码
                ├── props.js        // props相关定义的声明
                ├── const.js        // 常量
            ├── index.js            // 统一出入口
```

### 未来

1. 文档和用例在源码文件的 `docs` 和 `demo` 目录进行维护。为什么要这样做？

   - 首先，这样可以更好的进行维护，相关组件的相关文档和 `demo` 都集中在同一个组件目录下，更清晰，简洁。目前的写法是比较繁琐的，维护成本也不低。
   - 其次，可以通过脚本的形式把文档项目的内容编译到最终的 `docs` 文档目录下，`demo` 相关的文件内容编译到 `examples` 目录下，实现自动化引入，减少维护成本。

     ```js
     // 基础组件示例
     ├── select                         // Select组件的开发目录
         ├── style                      // 组件相关样式代码
         ├── demo                       // demo演示源码目录，这里会配合开发工具和脚本实现渲染展示
         ├── docs                       // docs文档说明
         ├── src                        // 组件源码目录
             ├── index.vue              // 组件源码
             ├── props.js               // props相关定义的声明
             ├── const.js               // 常量
         ├── index.js                   // 统一出入口
     ```

2. **webpack** 的 `markdown` 和 `vue` 文件的 **loader** 实现，做到可以自由渲染 `markdown` 文件和嵌在其中的 `vue` 类型代码，以及后期路径写法的编译实现，做到更简洁的文档维护方案，减少大量重复代码。
3. 路由自动化，统一开发目录的组件统一出口，实现 `docs` 与 `examples` 目录的路由自动化关联使用。

## 如何参与开发

本项目采用 **monorepo** 方案，使用 `pnpm workspaces + changeset` 管理，在开发之前，你需要先安装 [pnpm](https://pnpm.io/installation)。

```sh
npm install -g pnpm
```

考虑到网络问题，你可以安装 nrm 管理镜像源 [nrm](https://www.npmjs.com/package/nrm)

```sh
npm i nrm -g
# 查看可选源
nrm ls
# 使用源
nrm use taobao
```

### 安装依赖

1. 安装依赖

   ```sh
   # 默认会安装所有子项目的依赖
   pnpm install
   ```

   ```sh
   # 安装到全局 -w
   pnpm add -Dw <package-name>
   ```

2. 安装到指定子项目中

   ```sh
   pnpm add <package-name> --filter <target-package-name>

   # 比如要将lodash装到package-a下
   # --filter 后面可以为目录名称也可以为 package.josn 的 name 名称
   pnpm add dayjs --filter @ah-ailpha/package-a
   ```

   或者你也可以单独进入到需要的工作区安装依赖（不建议此方式）

   ```sh
   cd package-a && pnpm i xx -D
   ```

3. 创建或进入子项目中进行开发

   - `mkdir xx && cd xx && npm init -y` 快速创建一个子项目
   - 你需要确保的是 `package.json`文件的 name 必须以`@ah-ailpha/xx`这样的形式命名

4. 确定包版本

   - 本项目包版本和 CHANGELOG 日志由 changeset 控制，你只需要执行以下脚本即可，在开始之前你应该已经了解了[semver 规范](https://semver.org/lang/zh-CN/spec/v2.0.0.html)
   - 执行以下命令后会出现交互式 CLI，请选择自己的子项目，并根据自己的子项目确定版本更新

   ```sh
   # 1. 预构建选择版本
   pnpm run changeset
   # 2. 确定版本
   pnpm run version
   ```

5. 发布包到 npm

   该脚本命令一律要求在项目根目录下执行，如果只涉及自己负责的子项目，可以选择第二种方式

   ```sh
   # 先构建项目再发布包
   pnpm run release
   ```

### 开发调试

开发阶段我们关注 examples 目录，作为我们的开发调试目录

示例：

当我们需要进行 `@ah-ailpha/pro-sqltiptree`包的开发调试时，首先在根目录下执行安装命令

```sh
pnpm i @ah-ailpha/pro-sqltiptree@* --filter examples
```

这里我们选择指定版本为 \*，方便我们进行开发调试，保证依赖为实时最新状态

## 如何使用

在使用方式上应该和使用 npm 包一样

### 安装

```bash
# 基础组件
npm i --save @ah-ailpha/components
# 高级组件
npm i --save @ah-ailpha/pro-sqltiptree
```

### 注册

如果使用 Vue 默认的模板语法，需要注册组件后方可使用，有如下三种方式注册组件：

**全局完整注册**

```js
import AhComponents from '@ah-ailpha/components'
import AhProSqlTipTree from '@ah-ailpha/pro-sqltiptree'

app.use(AhComponents).use(AhProSqlTipTree)
```

**全局部分注册**

```js
import { Button } from '@ah-ailpha/components'

app.use(Button)
```

**局部注册组件**

```html
<template>
  <ah-button type="primary">Primary Button</ah-button>
  <ah-proSqlTipTree>AhProSqlTipTree组件</ah-proSqlTipTree>
</template>
<script>
  import { Button } from 'ant-design-vue'
  import ProSqlTipTree from '@ah-ailpha/pro-sqltiptree'
  // import AhProSqlTipTree from '@ah-ailpha/pro-sqltiptree'

  export default {
    components: {
      AhButton: Button,
      AhProSqlTipTree: ProSqlTipTree,
      // AhProSqlTipTree
    },
  }
</script>
```

局部注册组件需要保证组件命名空间符合约定规则，即 `Ah`为前缀，因为该场景下是手动自行注册，组件`name`不可控，不同于全局`Vue.use`会自动使用定义的`name`完成注册。
