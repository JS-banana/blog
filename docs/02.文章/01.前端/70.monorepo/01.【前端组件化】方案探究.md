---
title: 【前端组件化】方案探究
date: 2022-08-18 10:06:18
permalink: /pages/f120e1/
categories:
  - 文章
  - 前端
tags:
  - monorepo
---

> 前端组件化系列文章 第一篇

## 背景

公司目前基于多业务部门，很多业务组件和功能逻辑都具有较高的普适性，但与此同时各业务部分和开发人员缺乏一定的交流平台，更多的是在遇到对应需求时会简单内部讨论一番，当了解到其他业务部分存在落地的方案时，再进一步进行沟通交流。

这种方式，总体来说还是比较原始的，无论从沟通方式的效率来说，还是对于组件业务逻辑的深入理解都是非常低效的。因此，对于探索一种高效的、简单高效的、现代化方案是非常有必要的。

这也就是本系列文章的真实背景，目前前端组件化方案由我进行探索落地，主要流程和方案已基本完成，相关文章会按照系列形式输出，并确保文章内容都是在真实业务中的实践总结。

<!-- more -->

## 前端的发展路径

在互联网早期阶段，传统的开发模式中，往往是把前端的网页代码和后端的程序代码混合在一起，借助某种模板技术（如 JSP、ASP、PHP）来在服务器端动态生成 HTML 页面。

在这种开发模式下，网页的每次改动都需要前后端人员共同参与才能完成，网站前后端的开发人员需要很大的沟通成本、协调成本。企业招人的时候，也不得不招一些既懂前端又懂后端程序员，来减少前后端开发人员的冲突。

可以发现这种模式是非常低效的。

现在流行的前后端分离的开发模式，就是让后端只负责给前端提供数据，由前端负责整个页面的模板渲染、数据填充以及交互逻辑。

前后端分离之后，人们发现前端已经不再是传统意义上的网页了，它甚至还可以做成一个手机应用，或者做成是微信小程序那样的小型应用，**它更接近于传统的 B/S（客户端/服务器）架构，且仍然具备网页轻量级、无需下载和安装的优势**。

## 为什么需要组件化

组件化的目的：

1. 为了让页面中的各个部分可以被复用，以减少重复的代码。

2. 另一方面，也可以更好地使团队分工协作，让不同的人负责编写不同的组件。

对于需要开发复杂的大型应用的企业来说，组件化开发能极大地提高开发效率，它让前端开发团队能高效地完成工作，是一个非常有用的技术。

从广义的角度来说，现在的前端组件化的概念已不单单为页面组件了，它包括对应的工程化配置、开发规范、构建和发布流程、组件开发维护、工具类库SDK等

## 什么是组件化

在前后端分离的现代开发模式下，以`React`、`Vue`为例，涌现了很多优秀的现代化的前端框架，得益于新技术的发展，SPA 应用已经相当成熟，该开发范式也是相当普遍，各个互联网公司基本都迈入了。

伴随着这种技术行为，组件化开发也是应运而生，作为一个非常常规的模式，围绕几点说明：

1. 方便复用（很多业务代码、功能代码都不可避免有所重复，对于组件的复用使用，可谓作用很大）
2. 方便维护（如果大量的业务代码与功能代码耦合一起，对于代码的日后维护和功能拓展都有着很大的局限性和不足）
3. 功能细分、专一、职责明确（组件的核心原则就是，一个组件只做一件事，而且其不应该是有上下强关联耦合性的，可以随用随取，做到职责单一，对于日后功能迭代和代码维护好处都是显而易见的）

## 基本目标

> 核心述求：
>
> 1. 不同的业务平台开发的组件能够最大程度复用；
>
> 2. 新人能够快速了解通用组件，提升开发效率

1. 提供一个方便不同业务平台组件复用的方案
   - 主要围绕业务组件、二次封装的功能组件进行管理
   - 使用时类似 npm 包一样，直接进行安装使用
   - 组件迭代维护要足够方便
2. 文档网站平台搭建
   - 组件的基本 api、参数类型、示例、作用，使用文档等要有描述
   - 真实组件的渲染，可交互，最好能直接复制代码
   - 可访问查看的一个文档网站
3. 以 npm 包的形式+文档为最终效果
   - 对于多个不同的业务组件，由清晰的文档可查
   - 直接安装使用

## 技术背景

以公司实际项目为背景思考，主要围绕 vue2 相关技术栈进行前端 web 后台类系统的开发。

具体落地方案会和 vue2的技术栈有所关联，有些许影响，但是，组件化的整体思路不变，基本是相通的。而且按照我的习惯，一定会死磕到底，技术栈会按照较新的技术路线，在设计上会竭力为未来拓展准备。

1. 当前计划主要按照公司需求背景以 vue2为技术核心进行组件化的方案探索落地。
2. 在公司项目完成之后，再进行vue3和react技术栈的实践，并同步产出对应落地方案。

### 包依赖

我们公司当前项目平台主要依赖分析，如下：

- 核心三大件：`vue`/`vue-router`/`vuex`
- UI 类：`view-design`、`codemirror`、`monaco-editor`、`vue-echarts`、`vuedraggble`
- 工具类：`lodash`、`dayjs`、`uuid`

围绕以上技术相关生态，做到对各部分及功能使用的二次封装管理

主要 API 及实际项目代码分析：

- **slot**：组件拆分、UI 布局、自定义展示区域的好方法
- **props**：父组件向子组件传递参数
- **ref**：父组件获取子组件方法、属性
- **emit**：子组件向父组件传递参数，触发父组件绑定事件方法
- **provide/inject**：多级子父组件传值
- **vuex**：第三方状态管理（需要考虑单一组件的可维护性）

总的来说组件封装较频繁使用的属性方法为：`props`/`slot`/`emit`/`ref`

vuex 的使用需要谨慎考虑，具有一定的耦合性，需要进一步探索分析。

对于更优的方式探索值得思考，核心点为职责单一独立、耦合性低，方便维护。

### 业务组件

当前项目已存在的一些业务组件分析：

1. 存在大量的基于基础 UI 组件封装的一些功能组件，属于比较基础类的
2. 其次，存在着基于上述基础组件封装，进而进一步组合封装的业务组件
   - 举例：单个`FilterBtn组件`、`Table组件`、`Pagination组件`，进而组合成整体的一个组件，如：`pro-table`（包含列表、筛选、分页）
   - 举例：使用频率相当高的 `ComSqlTipTree组件`，也是集合了众多子组件的一个组合(涉及到对`Input`的高级封装、`Select`、列表等)

### 小结

基本分析结果思考：

可以参照`pro-component`高级组件的管理模式进行处理。

即，大量基于基础组件封装而成的高级组件，如：`pro-layout`、`pro-table`、`pro-form`等，每个组件可以作为独立的`npm`包作为依赖使用，相互独立、互不影响。

因此，基本确定可以为多包管理的方向（Monorepo）。

## 技术调研

围绕项目技术背景和目标规划，进行相关技术调研。

### 相关开源项目分析

1. 需要考虑的方向是：对于 vue2.x 版本的组件化方案，哪种更为合适（目前市面上有大量的vue3组件库）
2. vue2 对于 TS 的考虑 （vue2对ts的支持性一般，是否支持视情况而定）
3. 对props 参数 API 的文档、demo演示，文档网站建设的考虑
4. 目录设计、工程规范、构建发布流程

- [element](https://github.com/ElemeFE/element)
  - 无 monorepo，属于比较传统的单一包管理项目
  - 比价经典的vue2组件库项目，文档网站风格很不错
  - 主要使用 js + vue开发，构建由webpack处理
  - 文档网站由自身组件开发搭建，结合webpack loader实现对markdown文件的编译及demo示例的渲染
- [vuetify](https://github.com/vuetifyjs/vuetify)
  - lernajs + yarn + workspace 的方案，标准的 lernajs + yarn 用法
  - vue2.x + ts 写法，组件大量以 JSX 实现，具有很好的参考学习价值（vue2 中对 TS 的使用）
  - 文档网站由自身组件自行开发搭建，项目代码较多，有一定的上手成本
- [element-plus](https://github.com/element-plus/element-plus)
  - vue3 的项目，pnpm + workspace 的方案，整体思路和设计非常现代化
  - 组件实现由 vue编写开发，相关脚本代码由 TS编写，整个项目为 TS项目
  - 多包目录设计、组件和文档目录设计合理
  - 相关构建工具包括 rollup、esbuild、vite
  - 文档网站由vitepress构建，并自行编写了处理markdown和vue demo的插件进行处理（vitepress只支持vue3）
- [idux](https://github.com/IDuxFE/idux)
  - vue3 的项目，pnpm + workspace 的方案，技术都比较新
  - 版本控制由 lerna管理
  - demo与docs的目录管理很不错，需要配合脚本实现最终的网站路由和渲染
  - 文档网站由 vitepress + 自身组件构建，并配合各种脚本实现对应功能
  - 构建工具主要为 gulp
  - 组件开发主要为 tsx形式

### monorepo 是什么

- Monorepo：所有依赖库完全放入一个项目工程
- Multirepo：多个依赖包独立进行 git 管理

monorepo 是把多个项目的所有代码放到一个 git 仓库中进行管理，多个项目中会有共享的代码则可以分包引用。整个项目就是有 root 管理的 dependencies 加上多个 packages，每个 package 也可以在自己的作用域引入自己的 dependencies。

该方案可以很好的帮助我们解决不同工作区对于相同依赖的管理，以及我们在开发时，包相互间依赖的管理。

### monorepo + lernajs + yarn

Lerna 是一种工具，针对使用 git 和 npm 管理多软件包代码仓库的工作流程进行优化。

Lerna 有两种管理项目的模式：

- Fixed/Locked 模式 (默认)： 所有的包共用一个版本号。
- Independent mode：不同包独立使用自己的版本，我们一般采用这种方式。在初始化的时候指定 --independent 参数

一般而言，在pnpm未出现前，相关workspace概念基本是配合 yarn一起使用（yarn有workspace功能），因为 npm是没有 workspace概念的，所以在很长的一段时间里，多包管理方案 monorepo都是与 yarn一起配合使用。

他解决了以下问题：

- 多业务组件、互相依赖、无法复用
- 发包流程复杂、版本管理痛苦

#### 依赖管理

在工作区 packages 下面我们有这些包：`iview`、`pro-sqltiptree`、`components`，其 package.json 中的 name 定义分别为`@ah-ailpha/iview`、`@ah-ailpha/pro-sqltiptre`、`@ah-ailpha/components`，在我们相互安装包时，lerna 工具可以帮我们以用软链接的形式直接使用。（对于软链接的概念可以参考 npm link，以及pnpm的底层实现逻辑）

```sh
# 向 module-2 中添加 module-1 作为依赖
$ lerna add module-1 --scope=module-2
```

#### 版本管理

对于monorepo的多包场景，lerna另一大核心功能就是可以很好的帮助我们管理每个包的版本，通过使用 lerna version命令即可（可结合命令式交互快速管理版本）

lerna version 在背后为我们做了这些事：

- 识别出自上次发布以后更新过的包；
- 提示选择新版本；
- 修改包的元数据来反映最新发版（修改包的版本号），在根目录和每个包里面运行生命周期脚本；
- 对提交打 tag；
- 推送到远程代码仓库。

### monorepo + pnpm + workspace

pnpm现在也支持workspace的概念了[工作空间（Workspace）](https://pnpm.io/zh/workspaces)

pnpm 内置了对单一存储库（也称为多包存储库、多项目存储库或单体存储库）的支持， 你可以创建一个 workspace 以将多个项目合并到一个仓库中。

一个 workspace 的根目录下必须有 `pnpm-workspace.yaml` 文件， 也可能会有 `.npmrc` 文件。

如何高效的使用 pnpm，需要了解几个常用的基本命令

- `--filter`：过滤，过滤允许您将命令限制于包的特定子集，一般用于 packages/\* 下面的子项目。
- `-C`：在 `<path>` 中启动 pnpm ，而不是当前的工作目录。
- `-r`：安装在所有 packages 中（一般配合`--filter`指定项目目录）
- `-w`：表示把包安装在 root 下，该包会放置在 `<root>/node_modules` 下

pnpm同样可以实现对包依赖的管理，类似lerna一样

```sh
pnpm add <package-name> --filter <target-package-name>

# 比如要将lodash装到package-a下
# --filter 后面可以为目录名称也可以为 package.josn 的 name 名称
pnpm add dayjs --filter @ah-ailpha/package-a

# 向 module-2 中添加 module-1 作为依赖
pnpm add module-1 --filter module-2
```

### lerna / changeset 版本管理分析

不管对于 yarn还是 pnpm来说，都只是对于工作空间 woekspace的多包管理，对于依赖管理，pnpm目前可以支持，而yarn是需要lerna进行协助的。

但是对于各包的version版本控制，两者都不直接参与管理，只能使用第三方工具进行处理。

#### lerna

目前已知的比较成熟的方案有lerna，也是使用比较频繁的，好处是其功能比较全面，但也存在一些明显的问题

1. 不能和pnpm很好的适配，lerna 本身不支持 workspace 协议，导致基于 pnpm 开发的一些仓库无法使用
2. lerna version 根据 commit 以及 tag 更新出来的包版本不符合预期
3. 整个包的体积很大，依赖特别多（轻量版[lerna-lite](https://www.npmjs.com/package/@lerna-lite/cli)）

#### changeset

Changesets 是一个用于 Monorepo 项目下版本以及 Changelog 文件管理的工具。

> 目前一些比较火的 Monorepo 仓库都在使用该工具进行项目的发包例如 pnpm、mobx 等

changesets 主要关心 monorepo 项目下子项目**版本的更新**、**changelog 文件生成**、**包的发布**。

一个 changeset 是个包含了在某个分支或者 commit 上改动信息的 md 文件，它会包含这样一些信息:

- 需要发布的包
- 包版本的更新层级(遵循 semver 规范)
- CHANGELOG 信息

总的来说，changeset的工作内容还是比较明确的，我们需要直接参与的就是包版本的管理与发布，对于changelog的文件生成会由脚本自动处理，我们无需关心（需要按照commitlint规范提交message）

1. changeset init

   - 新项目执行该命令，完成对项目的初始化
   - 会在根目录下生成 .changeset 目录，`config.json`配置文件

2. changeset

   - 执行该命令，进行版本管理，会交互式选择不同项目，以及确定发布的版本
   - 会生成一些 .md 文件在目录下，会在 version 的时候消耗

3. changeset version

   - 消耗上一步生成的相关的一些版本信息及记录内容的 .md 文件，并生成或更新 CHANGELOG.md 文件，之后 .md 文件会被自动删除
   - 相应的 package.json 中的 version 信息也会同步更新

4. changeset publish

   - 发布包到远程 npm 源
   - 前置条件是你已经进行了 npm 账户登录，如果包名称为 `@ah-ailpha/components`该类型，还需要在 npm 账户中设置组织

#### 版本控制管理小结

对于采用pnpm + workspace方案的monorepo，可以选择使用 changeset进行版本管理控制，简单快速搭建一个完整的 monorepo项目。

## 资料

- [pnpm](https://pnpm.io/zh)
- [pnpm-workspaces](https://pnpm.io/zh/workspaces)
- [element](https://github.com/ElemeFE/element)
- [vuetify](https://github.com/vuetifyjs/vuetify)
- [element-plus](https://github.com/element-plus/element-plus)
- [idux](https://github.com/IDuxFE/idux)
- [lernajs](https://www.lernajs.cn/)
- [Lerna 运行流程剖析](https://www.zoo.team/article/lerna-js)
- [pnpm 多包管理项目-爱代码爱编程](https://icode.best/i/54395246194902)
- [Changesets: 流行的 monorepo 场景发包工具](https://juejin.cn/post/7024827345059971080)
