---
title: 【vite】vite + vue3 + setup + pinia + ts 爽到飞起
date: 2021-11-22 19:26:19
permalink: /pages/2833ad/
categories:
  - 文章
tags:
  - vite
  - vue
---

`vite` + `vue3` + `setup` + `pinia` + `ts` 爽到飞起，谁用谁知道，纵享丝滑般的体验~

<!-- more -->

## 前言

前两天接到了一个需求，就是把原来的一个项目的主要功能模块和用户模块权限系统抽出来做一个新后台项目，并迭代新增一些新功能，看起来好像也没啥东西

拿到源码看了下项目，好家伙，原项目是个微应用项目，主应用用户模块是`react`技术栈，子应用模块是`vue2`技术栈，这直接 CV大法看样子是不行了👀，我这要做的毕竟是个单页面应用，确定一个技术路线即可，具体看下代码逻辑并跑起来看看

跑起来试了下，两个项目基本都是1分钟左右启动，看代码vue项目整个业务逻辑代码都拧在一块写了

想到之前问老大要源码的时候，说那个是老项目了，重新搭一个写应该会快点

这话没毛病啊，话不多说，直接开整，这次直接上 `vite` + `vue3`

## 介绍

一个使用 `vite` + `vue3` + `pinia` + `ant-design-vue` + `typescript` 完整技术路线开发的项目，秒级开发更新启动、新的`vue3 composition api` 结合 `setup`纵享丝滑般的开发体验、全新的 `pinia`状态管理器和优秀的设计体验（`1k`的size）、`antd`无障碍过渡使用UI组件库 `ant-design-vue`、安全高效的 `typescript`类型支持

## 特性

- ✨脚手架工具：高效、快速的 **Vite**
- 🔥前端框架：眼下最时髦的 **Vue3**
- 🍍状态管理器：`vue3`新秀 **Pinia**，犹如 `react zustand`般的体验，友好的api和异步处理
- 🏆开发语言：政治正确 **TypeScript**
- 🎉UI组件：`antd`开发者无障碍过渡使用 **ant-design-vue**，熟悉的配方熟悉的味道
- 🎨css样式：**less** 、`postcss`
- 📖代码规范：**Eslint**、**Prettier**、**Commitlint**
- ✊依赖按需加载：**unplugin-auto-import**，可自动导入使用到的`vue`、`vue-router`等依赖
- 💪组件按需导入：**unplugin-vue-components**，无论是第三方UI组件还是自定义组件都可实现自动按需导入以及`TS`语法提示
- 🔒权限管理：页面级、菜单级、按钮级、接口级

## 开发

### 项目初始化

> 如果使用vscode编辑器开发vue3，请务必安装Volar插件与vue3配合使用更佳（与原本的Vetur不兼容）

使用 vite cli 快速创建项目

`yarn create vite project-name`

### 安装相关依赖

推荐使用新一代 `pnpm` 包管理工具，性能和速度以及 `node_modules`依赖管理都很优秀

建议配合 `.npmrc` 配置使用

```sh
# 提升一些依赖包至 node_modules
# 解决部分包模块not found的问题
# 用于配合 pnpm
shamefully-hoist = true

# node-sass 下载问题
# sass_binary_site="https://npm.taobao.org/mirrors/node-sass/"
```

## 功能支持

### vite plugins

```json
{
    "@vitejs/plugin-legacy": "^1.6.2", // 低版本浏览器兼容
    "@vitejs/plugin-vue": "^1.9.3", // vue 支持
    "@vitejs/plugin-vue-jsx": "^1.2.0", // jsx 支持
}
```

### ant-design-vue、Element Plus 等UI框架按需加载

- **unplugin-vue-components**

推荐使用 [unplugin-vue-components](https://github.com/antfu/unplugin-vue-components) 插件

该插件只需在 vite plugin中添加对应 `AntDesignVueResolver` 即可，也支持自定义的 `components` 自动注册，很方便

```ts
import { AntDesignVueResolver } from 'unplugin-vue-components/resolvers';
import Components from 'unplugin-vue-components/vite';

// vite.config.ts plugins 添加如下配置
export default defineConfig({
  plugins: [
    Components({
      resolvers: [
        AntDesignVueResolver(), // ant-design-vue
        // ElementPlusResolver(), // Element Plus
        // VantResolver(), // Vant
      ]
    })
  ]
})
```

当然这里如果没有你使用的对应的UI框架的 `Resolver`加载器，也没关系，也支持自定义配置

```ts
Components({
  resolvers: [
    // example of importing Vant
    (name) => {
      // where `name` is always CapitalCase
      if (name.startsWith('Van'))
        return { importName: name.slice(3), path: 'vant' }
    }
  ]
})
```

- **vite-plugin-style-import**

```js
import styleImport from 'vite-plugin-style-import'

// 
plugins:[
  styleImport({
    libs: [
      {
        libraryName: 'ant-design-vue',
        esModule: true,
        resolveStyle: (name) => {
          return `ant-design-vue/es/${name}/style/index`
        },
      }
    ]
  })
]
```

不过，我之前在写 `vite` + `react` 时，使用`vite-plugin-style-import`这个插件遇到过热更新样式不同步的一些问题

### 自定义主题

自定义主题设置参考官方文档配置即可，两种常规方式

1. 按需加载配合 `webpack/vite` less属性修改变量
2. 全量引入，配合 `variables.less`自定义样式覆盖框架主题样式

```ts
css: {
  preprocessorOptions: {
    less: {
      modifyVars: { 'primary-color': 'red' },
      javascriptEnabled: true,
    },
  },
}
```

**注意**：在使用了 `unplugin-vue-components`进行按需加载配置后，相关 less变量设置需要同步开启 `importStyle: 'less'`，[unplugin-vue-components issues 160](https://github.com/antfu/unplugin-vue-components/issues/160)

```ts
AntDesignVueResolver({ importStyle: 'less' })
```

### 自动导入

- **unplugin-auto-import**

vue相关 `defineComponent` 、`computed` 、`watch`等模块依赖根据使用，插件自动导入，你无需关心 `import`，直接使用即可

该插件默认支持：

- `vue`
- `vue-router`
- `vue-i18n`
- `@vueuse/head`
- `@vueuse/core`
- ...

当然你也可以自定义配置 [unplugin-auto-import](https://github.com/antfu/unplugin-auto-import#readme)

用法如下：

```ts
import AutoImport from 'unplugin-auto-import/vite'

export default defineConfig({
  // ...
  plugins: [
    AutoImport({
      imports: [
        'vue',
        'vue-router',
        'vue-i18n',
        '@vueuse/head',
        '@vueuse/core',
      ],
      dts: 'src/auto-imports.d.ts',
    })
  ]
})
```

需要在`src`目录下添加 `auto-imports.d.ts`文件配合使用，该文件会被插件自动更新

- **unplugin-vue-components**

该插件不仅支持UI框架组件的按需导入，也支持项目组件的自动化导入

配置如下:

```ts
Components({
  // allow auto load markdown components under `./src/components/`
  extensions: ['vue', 'md'],

  // allow auto import and register components used in markdown
  include: [/\.vue$/, /\.vue\?vue/, /\.md$/],

  dts: 'src/components.d.ts',
})
```

需要在`src`目录下添加 `components.d.ts`文件配合使用，该文件会被插件自动更新

- `auto-imports.d.ts`、`components.d.ts` 作用

显性的作用是：在项目下生成对应`.d.ts`type类型文件，用于引用的类型检测通过

内部是插件自动处理，把相关依赖导入组件

- **注意**

> `"unplugin-vue-components": "^0.17.2"`

当前版本已知问题：[issues 174](https://github.com/antfu/unplugin-vue-components/issues/174)

对于 `ant-design-vue` 的 `notification` / `message` 组件，当在 `js`中使用时，该插件不会执行自动导入能力（样式不会被导入）

最终效果是：`message.success('xx')`可以创建 `DOM`元素，但是没有相关样式代码

因为该插件的设计原理是根据 `template` 中的组件使用进行处理的

解决方案：

- `vite-plugin-style-import` 插件
- 手动全局引入 message组件样式，`import 'ant-design-vue/es/message/style'`

### mock数据

- **vite-plugin-mock** 插件

vite plugin配置

```ts
viteMockServe({
  ignore: /^\_/,
  mockPath: 'mock',
  localEnabled: !isBuild,
  prodEnabled: false,
  injectCode: `
      import { setupProdMockServer } from '../mock/_createProductionServer';

      setupProdMockServer();
      `,
})
```

根目录下创建 `_createProductionServer.ts`文件

```ts
import { createProdMockServer } from 'vite-plugin-mock/es/createProdMockServer';

const modules = import.meta.globEager('./**/*.ts');

const mockModules: any[] = [];
Object.keys(modules).forEach((key) => {
  if (key.includes('/_')) {
    return;
  }
  mockModules.push(...modules[key].default);
});

/**
 * Used in a production environment. Need to manually import all modules
 */
export function setupProdMockServer() {
  createProdMockServer(mockModules);
}
```

这样mock目录下的非 `_`开头文件都会被自动加载成mock文件

如：

```ts
import Mock from 'mockjs';

const data = Mock.mock({
  'items|30': [
    {
      id: '@id',
      title: '@sentence(10, 20)',
      account: '@phone',
      true_name: '@name',
      created_at: '@datetime',
      role_name: '@name',
    },
  ],
});

export default [
  {
    url: '/table/list',
    method: 'get',
    response: () => {
      const items = data.items;
      return {
        code: 0,
        result: {
          total: items.length,
          list: items,
        },
      };
    },
  },
];
```

配置好代理直接请求 `/api/table/list` 就可以得到数据了

### Proxy代理

```ts
import proxy from './config/vite/proxy';

export default defineConfig({
  // server
  server: {
    hmr: { overlay: false }, // 禁用或配置 HMR 连接 设置 server.hmr.overlay 为 false 可以禁用服务器错误遮罩层
    // 服务配置
    port: VITE_PORT, // 类型： number 指定服务器端口;
    open: false, // 类型： boolean | string在服务器启动时自动在浏览器中打开应用程序；
    cors: false, // 类型： boolean | CorsOptions 为开发服务器配置 CORS。默认启用并允许任何源
    proxy,
  },
})
```

proxy 如下

```ts
import {
  API_BASE_URL,
  API_TARGET_URL,
} from '../../config/constant';
import { ProxyOptions } from 'vite';

type ProxyTargetList = Record<string, ProxyOptions>;

const ret: ProxyTargetList = {
  // test
  [API_BASE_URL]: {
    target: API_TARGET_URL,
    changeOrigin: true,
    rewrite: (path) => path.replace(new RegExp(`^${API_BASE_URL}`), ''),
  },
  // mock
  // [MOCK_API_BASE_URL]: {
  //   target: MOCK_API_TARGET_URL,
  //   changeOrigin: true,
  //   rewrite: (path) => path.replace(new RegExp(`^${MOCK_API_BASE_URL}`), '/api'),
  // },
};

export default ret;
```

### 环境变量 .env

我这边是把系统常量配置放到 `config/constant.ts` 管理了，场景比较简答方便些

为了方便管理不同环境的接口和参数配置，可以使用环境变量 .env，如 .env、.env.local、.env.development、.env.production

配合 `dotenv`库 使用还是很方便的

## 路由和布局

新版路由 `vue-router4.x` 是有一些变化的，这里不再赘述

布局使用的是 `@ant-design-vue/pro-layout` 结合路由配置，使用起来比较方便

用法如下：

```ts
// router.config.ts
import BasicLayout from '/@/layouts/BasicLayout.vue'; // 基本布局
import BlankLayout from '/@/layouts/BlankLayout.vue'; // 空布局
import type { RouteRecordRaw } from 'vue-router';

const asyncRouterMap: RouteRecordRaw[] = [
  {
    path: '/',
    name: 'Root',
    redirect: '/app',
    meta: {
      title: 'Root',
    },
  },
  {
    path: '/login',
    component: () => import('/@/views/login/index.vue'),
    name: 'login',
    meta: { title: '登录' },
  },
  {
    path: '/app',
    name: 'index',
    component: BasicLayout,
    redirect: '/app/sys',
    meta: { title: '管理平台' },
    children: [
      {
        path: '/app/sys',
        component: BlankLayout,
        name: 'sys',
        redirect: '/app/sys/index',
        meta: {
          title: '首页',
          keepAlive: true,
          icon: 'icon-a-SimpleChainlianmenglianjichubantubiao_liulanqi',
        },
        children: [
          {
            path: '/app/sys/index',
            name: 'sys_index',
            component: () => import('/@/views/sys/index.vue'),
            meta: { hideInMenu: true },
          },
          {
            path: '/app/sys/detail',
            name: 'sys_detail',
            component: () => import('/@/views/sys/tradingDetail/index.vue'),
            meta: { title: '交易信息', breadcrumb: true, hideInMenu: true, hiddenWrap: true },
          },
        ],
      },
    ]
  }
]
```

在看看 `pro-layout`组件的使用

```vue
<template>
  <pro-layout
    :locale="locale"
    v-bind="layoutConf"
    v-model:openKeys="state.openKeys"
    v-model:collapsed="state.collapsed"
    v-model:selectedKeys="state.selectedKeys"
    :breadcrumb="{ routes: breadcrumb }"
  >
    <router-view />
  </pro-layout>
</template>  

<script setup lang="ts">
const { menuData } = getMenuData(clearMenuItem(router.getRoutes()));

const layoutConf = reactive<BasicLayoutProps>({
  menuData: menuData, // 菜单数据
  ...prolayoutSetting, // 基本设置
});

</script>  
```

根据实际情况可以自定义处理 menuData数据，如我这里

`const menuData = clearMenuItem(router.getRoutes()).filter((n) => n.path.startsWith('/app/'))`

- `hideInMenu` 属性是配合 pro-layout组件使用的，可以使该菜单项不会在菜单中显示，如不想让 `/app/sys`带有子菜单
- `breadcrumb`、`hiddenWrap`则是我根据自身需求添加的

## 权限

几个关键词：`router.addRoutes`动态路由、`v-auth`指令、`axios`拦截
