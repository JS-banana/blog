---
title: vue3使用总结
date: 2021-11-29 19:34:48
permalink: /pages/33f292/
categories:
  - 文章
  - 前端
tags:
  - vue
---

熟悉API的使用，理解其运行原理

<!-- more -->

## 环境变量获取

`import.meta.env`

```ts
// console.log(import.meta.env)
{
    "BASE_URL": "/",
    "MODE": "development",
    "DEV": false,
    "PROD": true,
    "SSR": false
}
```

## ref和reactive

都可以用来定义响应式数据

### ref

主要用于定义基本类型，使用时需要通过 `.value` 读取或修改

基本类型：除去Object，包括：String、Number、boolean、null、undefined

```ts
// ref
const count = ref(0)

count.value++
console.log(count.value)
```

在定义基本类型时，响应式原理是与 vue2.x类似的 `Object.defineProperty()`，通过 `get`、 `set`读取、修改数据

不过，ref也可以定义引用类型的数据Object，但其内部实现则是借助 reactive

可以通过打印数据在控制台查看结构，分别为：`ImpI`、`Proxy`

### reactive

**只能**定义引用类型，即Object，包括：Object、Array、Date、function，定义基本类型时会警告

使用时，直接通过属性读写

```ts
// reactive
const state = reactive({count:0})

state.count++
console.log(state.value)
```

该响应式能力是通过 `ES6 Proxy`实现的，其可以做到对属性的**新增**、**删除**监听，解决了 `defineProperty`的缺陷，并且对嵌套属性有着良好的支持，可以轻松实现 `a.b.c.d=xx`的响应式更新，在通过与 `Reflect`方法的配合使用，可以很好的做到安全优雅的对属性做出调整更新

### 小结

模板 tempalte 会自动解包，在模板中使用时，不需要 `.value`

对于引用类型来说，简单理解即：**ref本质也是reactive，ref(obj)等价于reactive({value: obj})**，ref 的底层实现就是 reactive

可以发现，所谓响应式其实就是对属性的劫持

## shallowRef和shallowReactive

- 递归监听和非递归监听

ref和reactive都属于递归监听，也就是数据的每一层都是响应式的，如果数据量比较大，非常消耗性能，非递归监听只会监听数据的第一层。

## toRef和toRefs

相关文章：

- <https://juejin.cn/post/6977929393511514148>

## script setup 写法的 props 、context处理方式

3个新API

- defineProps
- defineEmit
- useContext

相关文章：

- <https://chengpeiquan.com/article/vue3-script-setup.html>

## props Type 类型定义问题

抛开 vue默认的几种基本类型，在一些特殊场景需要定义比较复杂的类型，需要通过 PropType 配合使用

如定义callback类型函数

```ts
props: {
    handleSubmit: {
        type: Function as PropType<() => void>,
        default: () => {},
    },
}
```

这里如果按照常规类型 Function定义会和 default冲突，并且当有参数传递时，原始类型写法也很难精确推导

## prop、ref、emit 数据通信

### prop

强调单项数据流 父=>子，主要用来传值参数给子组件

### ref

两种用法：

- 以引用的方式把子组件的实例指给 ref，使得可以在父组件中获取到子组件中的所有属性和方法

- 用于DOM元素

### emit

主要用于子组件向父组件传递参数和通信`emit`，父组件通过事件方法`@event`接收

```jsx
<!-- 父组件 -->
emit('getMessage', '我是父组件！')

<!-- 子组件 -->
<child @event="handleMethod">
```

## vue router4.x 路由问题
