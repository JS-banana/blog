---
title: vite + vue3 + ts 使用总结
date: 2021-11-29 19:34:48
permalink: /pages/33f292/
categories:
  - 文章
  - 前端
tags:
  - vue
---

现阶段开发 vue3 项目使用 vite + ts 应该已成为标准范式了吧，新的语法体验 vue composition api 再配合 script setup 谁用谁知道啊，开发和构建方面，vite 作为下一代构建工具，想必大家也有所了解，使用 ES6 module + ESbuild 支持本地开发，速度和效率起飞啊，就一个字——爽，对于 TypeScript，感觉都没必要说了，现在还没上车的赶紧的了~

<!-- more -->

## 前言

vite 作为一个构建工具，我们目前了解如何使用即可，该工具足够优秀，默认对很多功能都做到了支持（css module、less、scss），且其作为vue之父尤大大的作品，对于vue也有着较好的支持，目前使用率也已经很高了，nuxt等多个大项目都已支持，结合文档和社区，目前使用足够了，也无需担心疑难杂症~，快上车~

vue3，感觉变化最大的就是全面拥抱了函数式编程，结合 composition api 现在真的可以做到对于复杂业务代码的轻松管理，抛弃以前的 this this 一大堆，不友好的mixin ，使用现在的 hooks处理，逻辑复用、功能模块拆分简直太方便了，语法、api使用上也优雅方便了很多，很值得一试

另一大亮点就是 vue3对 TS的良好支持，现在项目可以全面拥抱 TS写法了，然后与 setup 再结合我接下来推荐的几款工具，组合起来使用，简直不要太爽

对于 TS，首先要做到对类型的定义，这是和传统写JS有所不同的地方，但是这一步却是很必要也很值得的，这对你接下来的工作或者说对于这个项目的以后都是有很大的好处

如这样一个场景，和后端接口对接：

在前期，我们拿到接口文档，按照格式和类型定义好对应 TS类型，并结合 Mock写好接口和业务逻辑，使用时通过TS可以高效的完成代码开发，同时可以极大的避免犯错，对于后期维护迭代有很大的保障

## import.meta

使用 vite做为构建工具，可以通过 `import.meta`获取对应方法方便快速的处理业务

### 环境变量获取

`import.meta.env`

```ts
// console.log(import.meta.env)
{
    "BASE_URL": "/",
    "MODE": "development",
    "DEV": false,
    "PROD": true,
    "SSR": false
}
```

### 批量处理文件

`import.meta.globEager`

```ts
// 读取当前目录下的所有 .ts文件
const modules = import.meta.globEager('./**/*.ts')
```

## ref和reactive

都可以用来定义响应式数据

### ref

主要用于定义基本类型，使用时需要通过 `.value` 读取或修改

基本类型：除去Object，包括：String、Number、boolean、null、undefined

```ts
// ref
const count = ref(0)

count.value++
console.log(count.value)
```

在定义基本类型时，响应式原理是与 vue2.x类似的 `Object.defineProperty()`，通过 `get`、 `set`读取、修改数据

不过，ref也可以定义引用类型的数据，注意，当定义引用类型时，其内部实现则是借助 reactive

可以通过打印数据在控制台查看结构，分别为：`ImpI`、`Proxy`

### reactive

**只能**定义引用类型，即Object，包括：Object、Array、Date、function，定义基本类型时会警告

使用时，直接通过属性读写

```ts
// reactive
const state = reactive({count:0})

state.count++
console.log(state.value)
```

reactive默认对对象内的所有属性都进行响应式处理，并可以实现深层监听

该响应式能力是通过 `ES6 Proxy`实现的，其可以做到对属性的**新增**、**删除**监听，解决了 `defineProperty`的缺陷，并且对嵌套属性有着良好的支持，可以轻松实现 `a.b.c.d=xx`的响应式更新

> `Proxy`与 `Reflect`均为ES6语法，一般他俩是一起配合使用，可以很好的做到安全优雅的对属性做出劫持更新

### 小结

模板 tempalte 会自动解包，在模板中使用时，不需要 `.value`

对于*引用类型*来说，简单理解即：**ref本质也是reactive，ref(obj)等价于reactive({value: obj})**，ref 的底层实现就是 reactive

可以发现，所谓响应式其实就是对属性的劫持

## watch、watchEffect

监听

### watch

### watchEffect

接收一个函数，不需要设置监听对象，该方法会自动接管函数内部使用到的依赖，当依赖发生更新时，触发该函数执行

该函数会初始化默认执行一次

```ts
watchEffect(()=>{

  if(state.count>1){
    // 只要 count变化，这个 watchEffect函数就会执行一次
    // 当 count > 1时，做对应行为
  }

})
```

### 小结

watch更强调动作，watchEffect强调过程

## shallowRef和shallowReactive

- 递归监听和非递归监听

ref和reactive都属于递归监听，也就是数据的每一层都是响应式的，如果数据量比较大，非常消耗性能，非递归监听只会监听数据的第一层。

## toRef和toRefs

相关文章：

- <https://juejin.cn/post/6977929393511514148>

## script setup 写法的 props 、context处理方式

3个新API

- defineProps
- defineEmit
- useContext

相关文章：

- <https://chengpeiquan.com/article/vue3-script-setup.html>

## props Type 类型定义问题

抛开 vue默认的几种基本类型，在一些特殊场景需要定义比较复杂的类型，需要通过 PropType 配合使用

如定义callback类型函数

```ts
props: {
    handleSubmit: {
        type: Function as PropType<() => void>,
        default: () => {},
    },
}
```

这里如果按照常规类型 Function定义会和 default冲突，并且当有参数传递时，原始类型写法也很难精确推导

## prop、ref、emit 数据通信

### prop

强调单项数据流 父=>子，主要用来传值参数给子组件

### ref

两种用法：

- 以引用的方式把子组件的实例指给 ref，使得可以在父组件中获取到子组件中的所有属性和方法

- 用于DOM元素

### emit

主要用于子组件向父组件传递参数和通信`emit`，父组件通过事件方法`@event`接收

```jsx
<!-- 父组件 -->
emit('getMessage', '我是父组件！')

<!-- 子组件 -->
<child @event="handleMethod">
```

## vue router4.x 路由问题
