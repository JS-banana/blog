---
title: NodeJs获取照片信息并分类
date: 2021-11-14 17:46:34
permalink: /pages/d42185/
categories:
  - 文章
  - NodeJs
tags:
  - 图片
---

NodeJs 获取照片拍摄日期，并按日期目录/名称存档

<!-- more -->

## 前言

一开始想着女朋友生日快到了，想准备个有意义的礼物啥的，看了手机和文件夹里的这么多照片（在一块拍了很多照片），干脆做个相册，也是一份很棒的回忆和纪念呀

初步想法是：

- 直接找朋友再打印一份实体相册（需要筛选分类挑一部分）
- 做个以相册功能为主的网站/小程序（这个还没想好，不过数据可以先准备着）

但是基本能力还是比较清晰的：

- 拍摄日期
- 分类

期待完善的能力是：

- GPS定位信息与可视化能力结合

这里还是以我比较熟悉的 Nodejs为例

## 能力分析

- 拍摄日期

不同于文件创建日期，拍摄日期是绝对稳定不变大的（文件日期会在移动时发生变化），这也是我们需要的，因此，这里就需要一些可以解析图片数据能力的开源库了，这里我使用的是 nodejs包 `exif`

它具有以下能力：

从图像（JPEG）中提取Exif元数据，相机在图像文件中保存关于图像的额外信息：相机型号、分辨率、图像的拍摄地点（GPS）或拍摄时间。

这里我简单列举部分属性：

[文档](https://www.npmjs.com/package/exif)

```js
{
  image: {
    ImageWidth: 3648,
    ImageHeight: 2736,
    Make: 'HUAWEI',
    ModifyDate: '2021:05:04 12:55:57',
    // ...
  },
  exif: {
    ISO: 200,
    DateTimeOriginal: '2021:05:04 12:55:57',
    CreateDate: '2021:05:04 12:55:57',
    LightSource: 1,
    Flash: 0,
    FocalLength: 5.58,
    // ...
  },
  gps: {
    // ...
  },
}
```

`CreateDate` 可以帮助我们按日期，以月或者年的维度去做一些归类处理，以时间轴...

`imgge`、`GPS`信息可以在开发相册网站功能时提供能力

解决了数据获取的问题后，接下来就是比较常规一些的操作了

## 根据日期简单分类

比如我这里打算以时间轴的形式去描述和分类

以2021年为例，按月份做细粒度划分

```js
// 先定义下分类

5: "521&南京游",
6: "端午",
7: "杭州游",
8: "七夕",
9: "大学城&中秋节",
// ...
```

那这里的话，可以结合自身需求：

- 是把照片按照月份归类到单独的文件夹去
- 还是把基本信息呈现在照片名称中

这里我为了做相册方便，先统一按名称划分处理

按文件夹划分对于整理和网站使用很可以的 👀

## 代码

开始之前先安装下常用依赖：`fs-extra`、`pify`

### 读取目录下的所有照片

这里按最简单处理，先不考虑嵌套递归

```js
const fs = require("fs-extra");
const pify = require("pify");

// 读取目录
const readDir = async () =>{
  const dir = await pify(fs.readdir(dirPath));
}
```

### 读取图片信息

- 格式过滤

```js
const path = require("path");

// 文件格式
const ext = path.extname(currentPath);
// .jpg
```

- 读取信息

```js
const Exif = require("exif");

const readImg = async (currentPath) => {
  const imgInfo = await pify(Exif.ExifImage)({
    image: currentPath,
  });
  // 文件格式
  const ext = path.extname(currentPath);

  // 获取日期 2021:05:04 12:55:57
  const createDate = imgInfo.exif.CreateDate
  const date = new Date(.replace(":", "-").replace(":", "-"));

  return {
    currentPath,
    date,
    ext
  }
}
```

这里为了方便处理，可以用 `Promise.all`包装一下

```js
const res = await Promise.all(dir.map(readImg))
```

- 按日期排序

```js
const sortData = res.sort((a, b) => a.date - b.date);
```

### 重命名处理

拿到 `sortData`数据，同样按照 dir的方式处理

```js
const result = await Promise.all(renameFile)
```

目标效果：`5月21日(521&南京游)-1.jpg`

```js
// 来自于入口函数
// toDir = ''
// sortArr={}

const renameFile = async () => sortData.map(async ({ currentPath, date, ext }) => {
    // 基本信息： 月 日 描述
    const month = date.getMonth() + 1;
    const day = date.getDate();
    const desc = MONTHS[month] || "未分类";

    // 以月份内部排序
    sortArr[month] = sortArr[month] || [];
    const len = sortArr[month].length + 1;
    sortArr[month].push(len);

    const fileName = `${month}月${day}日(${desc})-${sortArr[month].length}`;

    const newPath = toDir + fileName + ext; // 5月21日(521&南京)-1.jpg

    // 判断是否过滤已存在的目标文件
    if (fs.existsSync(newPath)) {
      console.log(currentPath, "已存在", newPath);
    }
    // 文件重命名
    if (!isDebug) {
      fs.renameSync(currentPath, newPath);
    }
    console.log(currentPath, "移动到", newPath);

    return { fileName, date };
})
```

主函数

```js
/**
 * @param {String} dirPath 来源目录
 * @param {String} toDir 目标目录
 * @param {Boolean} isDebug 是否调试模式。调试模式只会在控制台输出信息，不会真正操作文件
 */

const main = async (dirPath, toDir, isDebug = true) => {
  // 
}
```

### 完整代码如下

```js
const NmExif = require("exif");
const pify = require("pify");
const fs = require("fs-extra");
const path = require("path");

const MONTHS = {
  5: "521&南京游",
  6: "端午",
  7: "杭州游",
  8: "七夕",
  9: "大学城&中秋节",
};

const main = async (dirPath, toDir, isDebug = true) => {
  let prefix = "";
  let sortArr = {};

  // 不存在
  if (!fs.existsSync(dirPath)) return console.log("no path!");
  // 自动补齐路径符
  const SEP = path.sep;
  if (!dirPath.endsWith(SEP)) {
    dirPath += SEP;
  }
  if (!toDir.endsWith(SEP)) {
    toDir += SEP;
  }

  prefix = dirPath;

  // 读取目录
  const dir = await pify(fs.readdir(dirPath));

  // 读取时间
  const res = await Promise.all(
    dir.map(async (filePath) => {
      const currentPath = prefix + filePath;
      let date = "";

      // 文件格式
      const ext = path.extname(currentPath);

      if (!ext) return null;
      if (ext === ".jpg" || ext === ".jpeg") {
        // 有可能读取不到信息
        try {
          const createDate = await pify(NmExif.ExifImage)({
            image: currentPath,
          });

          // 5月21日(521&南京)-1.jpg
          date = new Date(createDate.exif.CreateDate.replace(":", "-").replace(":", "-"));
        } catch (error) {
          //
        }
      }

      return {
        currentPath,
        date,
        ext,
      };
    })
  );

  const sortData = res.sort((a, b) => a.date - b.date);

  const result = await Promise.all(
    sortData.map(async ({ currentPath, date, ext }) => {
      const month = date.getMonth() + 1;
      const day = date.getDate();
      const desc = MONTHS[month] || "未分类";

      sortArr[month] = sortArr[month] || [];
      const len = sortArr[month].length + 1;
      sortArr[month].push(len);

      const fileName = `${month}月${day}日(${desc})-${sortArr[month].length}`;

      const newPath = toDir + fileName + ext; // 5月21日(521&南京)-1.jpg

      // 判断是否过滤已存在的目标文件
      if (fs.existsSync(newPath)) {
        console.log(currentPath, "已存在", newPath);
      }
      // 文件重命名
      if (!isDebug) {
        fs.renameSync(currentPath, newPath);
      }

      return { fileName, date };
    })
  );

  console.log("result", result);
};

main("./origin_photos/", "./target_photos/", false);
```
