---
title: 发布订阅模式vs观察者模式
date: 2021-07-18 09:41:49
permalink: /pages/911929/
categories:
  - JavaScript
tags:
  - 设计模式
---

## 背景

最近在研究`react`的状态管理器`zustand`时，研究源码时发现其组件注册绑定是通过观察者模式结合`react hooks`实现更新的。而联想之前写`vue`的时候，经常会用到`vue`内置的自定义事件进行组件通信（`$emit`/`on`），这个好像是发布订阅模式，搞得我有点头大，感觉这两种模式又十分相似，自己也是有点迷糊，感觉没用理解透，因此，这次就顺势深入研究下这两种模式，再尝试自己手写一个加深下理解。这篇文章是我个人梳理的心得，如有错误欢迎指正，共同进步~

<!-- more -->

## 介绍

### 区别

**观察者模式**：在软件设计中是一个对象，维护一个依赖列表，当任何状态发生改变自动通知它们。

**发布-订阅设计模式**：消息的发送方（发布者）不会直接发送给特定的接收者（叫做订阅者），而是通过一个信息中介进行过滤和分配消息。

通俗形象点来说就是：

- **察者模式**没中间商赚差价，**发布订阅模式** 有中间商赚差价。
- **观察者模式**为一刀切模式，对所有订阅者一视同仁，**发布订阅模式**可以戴有色眼镜，有一层过滤或者说暗箱操作。

OK，引用一张图大家感受下

![侵删](https://user-gold-cdn.xitu.io/2017/11/22/15fe1b1f174cd376?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

### 总结一下

- 在**观察者**模式中，观察者是知道Subject的，Subject一直保持对观察者进行记录。然而，在**发布订阅**模式中，发布者和订阅者**不知道对方的存在**。它们只有通过消息代理进行通信。

- 在**发布订阅**模式中，组件是松散耦合的，正好和观察者模式相反。

- **观察者模式**大多数时候是**同步**的，比如当事件触发，Subject就会去调用观察者的方法。而**发布-订阅**模式大多数时候是**异步**的（使用消息队列）。

- **观察者**模式需要在单个应用程序地址空间中实现，而**发布-订阅**更像交叉应用模式。

## 发布订阅模式

`vue`自定义事件`Event Bus`就是发布订阅模式的实现，还有`Nodejs`的`Emitter Event`。

实现一个需要支持订阅、解绑、发布，同类型事件支持多次绑定。

### 来个简单实现

上代码

```js
// 订阅中心
const subscribers = {}
// 订阅
const subscribe = (type, fn) => {
  if (!subscribers[type]) subscribers[type] = []
  subscribers[type].push(fn)
}
// 发布
const publish = (type, ...args) => {
  if (!subscribers[type] || !subscribers[type].length) return
  subscribers[type].forEach((fn) => fn(...args))
}
// 取消订阅
const unsubscribe = (type, fn) => {
  if (!subscribers[type] || !subscribers[type].length) return
  subscribers[type] = subscribers[type].filter((n) => n !== fn)
}
```

验证测试

```js
// console test ======>
subscribe("topic-1", () => console.log("suber-A 订阅了 topic-1"))
subscribe("topic-2", () => console.log("suber-B 订阅了 topic-2"))
subscribe("topic-1", () => console.log("suber-C 订阅了 topic-1"))

publish("topic-1") // 通知订阅了 topic-1 的 A 和 B

// 输出结果
// suber-A 订阅了 topic-1
// suber-C 订阅了 topic-1
```

### 实现一个Emitter类

上代码

```js
class Emitter {
  constructor() {
    // 订阅中心
    this._event = this._event || {}
  }
  // 注册订阅
  addEventListener(type, fn) {
    const handler = this._event[type]

    if (!handler) {
      this._event[type] = [fn]
    } else {
      handler.push(fn)
    }
  }
  // 卸载订阅
  removeEventListener(type, fn) {
    const handler = this._event[type]

    if (handler && handler.length) {
      this._event[type] = handler.filter((n) => n !== fn)
    }
  }
  // 通知
  emit(type, ...args) {
    const handler = this._event[type]

    if (handler && handler.length) {
      handler.forEach((fn) => fn.apply(this, args))
    }
  }
}
```

验证测试

```js
// console test ======>
const emitter = new Emitter()

emitter.addEventListener("change", (obj) => console.log(`name is ${obj.name}`))

emitter.addEventListener("change", (obj) => console.log(`age is ${obj.age}`))

const sex = (obj) => console.log(`sex is ${obj.sex}`)

emitter.addEventListener("change", sex)

emitter.emit("change", { name: "xiaoming", age: 28, sex: "male" })

console.log("event-A", emitter._event)

emitter.removeEventListener("change", sex)

console.log("====>>>>")

emitter.emit("change", { name: "xiaoming", age: 28, sex: "male" })

console.log("event-B", emitter._event)

// 输出
// name is xiaoming
// age is 28
// sex is male
// event-A {change: Array(3)}

// ====>>>>

// name is xiaoming
// age is 28
// event-B {change: Array(2)}
```

### vue Event Bus 实现

#### 结构梳理

> 源码位置：[src/core/instance/events.js](https://github.com/vuejs/vue/blob/dev/src/core/instance/events.js)

首先我们根据源码分析下结构，梳理一下`vue`的`event`实现逻辑

1. 把事件中心保存到Vue实例上：

   `vm._events = {}`

2. 把所有的方法： `$on` 、 `$once` 、 `$off` 、 `$emit` 挂载到Vue原型上

  > 这样做的好处是可以在Vue组件中使用时直接 `this.$on` 、 `this.$emit`

   ```js
   // $on
   Vue.prototype.$on = function(){}
   // $once
   Vue.prototype.$once = function(){}
   // $once
   Vue.prototype.$off = function(){}
   // $once
   Vue.prototype.$emit = function(){}
   ```

#### 看代码

1. $on 添加注册

    ```js
    // $on
    Vue.prototype.$on = function (event, fn) {
      const vm = this

      // 如果传入的 event 监听事件类型为数组，递归调用 $on 方法
      if (Array.isArray(event)) {
        for (let i = 0, l = event.length; i < l; i++) {
          vm.$on(event[i], fn)
        }
      } else {

        // 如果存在直接添加，不存在新建后添加
        ;(vm._events[event] || (vm._events[event] = [])).push(fn)
      }

      // 返回实例，用于链式调用
      return vm
    }
    ```

2. $once 单次执行

    ```js
    // $once
    Vue.prototype.$once = function (event, fn) {
      const vm = this

      // 当该 event 事件触发时，调用 on 方法
      function on() {

        // 首先执行 $off 方法卸载 本回调方法
        vm.$off(event, on)

        // 再执行 本回调方法
        fn.apply(vm, arguments)
      }

      // 该赋值会在 $off 中使用：cb.fn === fn
      // 因为该 $once 方法调用的是 $on 添加回调，但是添加的是包装后的 on 方法而不是 fn 方法
      // 因此当我们单独调用 $off方法删除 fn 回调时，是找不到的，这时就可以通过 cb.fn === fn 判断
      on.fn = fn

      // 调用 $on 方法，把该回调添加到队列
      vm.$on(event, on)

      return vm
    }
    ```

3. $off 卸载删除

    ```js
    // $off
    Vue.prototype.$off = function (event, fn) {
      const vm = this

      // 如果不传入任何参数，清空所有的事件
      if (!arguments.length) {
        vm._events = Object.create(null)
        return vm
      }

      // 如果 event 为数组，同 $on 逻辑，递归卸载事件
      if (Array.isArray(event)) {
        for (let i = 0, l = event.length; i < l; i++) {
          vm.$off(event[i], fn)
        }
        return vm
      }

      // 回调列表
      const cbs = vm._events[event]

      // 如果该 event 事件不存在绑定回调，不处理
      if (!cbs) {
        return vm
      }

      // 如果未传入对应 event 的解绑回调，则清空该 event 的所有
      if (!fn) {
        vm._events[event] = null
        return vm
      }

      // event 事件类型和 回调 都存在，遍历查找删除 指定 回调
      let cb
      let i = cbs.length
      while (i--) {
        cb = cbs[i]
        if (cb === fn || cb.fn === fn) {
          cbs.splice(i, 1)
          break
        }
      }
      return vm
    }
    ```

4. $emit 触发事件

    ```js
    // $emit
    Vue.prototype.$emit = function (event) {
      const vm = this

      // 回调列表
      let cbs = vm._events[event]

      // 判断该 event 是否存在执行回调
      if (cbs) {

        // $emit方法可以传参，这些参数会在调用回调函数的时候传进去
        // 排除 event 参数的其他参数
        // toArray 是一个把类数组转换为数组的方法
        const args = toArray(arguments, 1)

        // 遍历回调函数
        for (let i = 0, l = cbs.length; i < l; i++) {
          cbs[i].apply(vm, args)
        }
      }
      return vm
    }
    ```

    <details><summary> toArray方法 </summary>

      ```js
      // Convert an Array-like object to a real Array.
      function toArray (list, start) {
        start = start || 0;
        var i = list.length - start;
        var ret = new Array(i);
        while (i--) {
          ret[i] = list[i + start];
        }
        return ret
      }
      ```

    </details>

#### 测试下

首先我们模拟一个Vue实例测试下

```js
// Vue类应置于原型方法上面
class Vue {
  constructor() {
    this._events = {}
  }
  get event() {
    return this._events
  }
}
```

验证下结果

```js
// 实例化
const myVue = new Vue()

// 添加方法
const update_user = (args) => console.log("user：", args)
const once_update_user = (args) => console.log("once_user：", args)

// 输出打印
myVue.$on("user", update_user)
myVue.$once("user", once_update_user)
console.log("events：", myVue.event)
// events： {user: [(args) => console.log("user：", args), ƒ on()]}

myVue.$emit("user", { name: "xiaoming", age: 18 })
console.log("events：", myVue.event)
// events： {user: [(args) => console.log("user：", args)]}
// user： {name: "xiaoming", age: 18}
// once_user： {name: "xiaoming", age: 18}

myVue.$off("user", once_update_user)
console.log("events：", myVue.event)
// events：{user: []}
```

### 小总结下

`Vue` 封装的这个发布订阅模式，可以说是很完善了，这个是完全可以独立抽取出来的在其他项目中使用的代码，只需要做一点点改动，把事件存储器换个地方（`Vue` 放在了实例上）

我们从最简单的几行代码，一直到框架中的细致完整实现，从中可以发现：其实只要我们思路对了，核心方法掌握理解了，基本就搞定了实现原理，剩下的大多都是对各种异常情况的判断和处理。

## 观察者模式

只要当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

我们最常接触的`DOM`事件绑定也是该模式，看下面这段代码

```js
document.querySelector('#btn').addEventListener('click',function () {
    alert('You click this btn');
},false)
```

`vue`的双向数据绑定就是观察者模式的实现。

![vue的双向数据绑定](https://user-gold-cdn.xitu.io/2018/10/23/166a031209fc8da5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

### 也来个简单实现

```js
// 观察者列表
const observers = []

// 添加
const addob = (ober) => {
  observers.push(ober)
}

// 通知
const notify = (...args) => {
  observers.forEach((fn) => fn(args))
}

// 测试 =======>
const subA = () => console.log("I am sub A")
const subB = (args) => console.log("I am sub B", args)

addob(subA)
addob(subB)
notify({ name: "sss", site: "ssscode.com" })
// I am sub A
// I am sub B [{name: "sss", site: "ssscode.com"}]
```

### 实现一个观察者类

上代码

```js
// 观察者
class Observer {
  constructor(name) {
    // 观察者 name
    this.name = name
  }

  // 触发器
  update() {
    console.log("观察者：", this.name)
  }
}

// 被观察者
class Subject {
  constructor() {
    // 观察者列表
    this._observers = []
  }

  // 获取 观察者列表
  get obsers() {
    return this._observers
  }

  // 添加
  add(obser) {
    this._observers.push(obser)
  }

  // 移除
  remove(obser) {
    this._observers = this._observers.filter((n) => n !== obser)
  }

  // 通知所有观察者
  notify() {
    this._observers.forEach((obser) => obser.update())
  }
}
```

验证测试下结果

```js
// 观察者
const obserA = new Observer("obser-A")
const obserB = new Observer("obser-B")

// 被观察者
const subject = new Subject()

// 添加到 观察者列表
subject.add(obserA)
subject.add(obserB)

// 通知
subject.notify()
console.log("观察者列表：", subject.obsers)
// 观察者： obser-A
// 观察者： obser-B
// 观察者列表： (2) [Observer, Observer]

// 移除
subject.remove(obserA)

// 通知
subject.notify()
console.log("观察者列表：", subject.obsers)
// 观察者： obser-B
// 观察者列表： [Observer]
```

### Vue 双向数据绑定

`Vue`在初始化时会遍历所有**指令**和**data**然后 `new Observer` 添加注册，放入被观察者 `Dep` 队列。

再通过对 `Object.defineProperty()` 这个方法对数据劫持，重新定义 `set` 和 `get` 方法，一旦数据变动，收到通知，更新视图。

这里我们简单看下 `Vue` 对 `data` 的响应式处理。渲染过程暂不分析。

有兴趣的朋友可以试着把源码下载下来，然后使用浏览器断点调试看一下 `new Vue` 的过程。

初始化 `initData`

```js
// 这里的 $options 其实就是我们在写 Vue 的时候
// new Vue({}) 中的 data、method、computed等属性。
function initData(vm) {
  // 对 data 进行处理，函数 / 对象
  let data = vm.$options.data
  // 为什么建议大家vue中的data使用函数式写法？
  // 当一个组件被定义， data 必须声明为返回一个初始数据对象的函数，因为组件可能被用来创建多个实例
  // 如果 data 仍然是一个纯粹的对象，则所有的实例将共享引用同一个数据对象
  // 通过提供 data 函数，每次创建一个新实例后，我们能够调用 data 函数，
  // 从而返回初始数据的一个全新副本数据对象。
  // (js在赋值object对象时，是直接一个相同的内存地址。所以为了每个组件的data独立，采用了这种方式。)
  data = vm._data = typeof data === "function" ? getData(data, vm) : data || {}

  // 
  observe(data, true /* asRootData */)
}
```

创建观察者 `observe`

```js
function observe(value, asRootData) {
  let ob
  // Observer
  ob = new Observer(value)
  // asRootData = true
  if (asRootData && ob) {
    ob.vmCount++
  }
  //
  return ob
}
```

观察者类 `Observer`

```js
class Observer {
  constructor(value) {
    this.value = value
    this.dep = new Dep()
    this.vmCount = 0
    if (Array.isArray(value)) {
      this.observeArray(value)
    } else {
      this.walk(value)
    }
  }

  // 处理所有属性
  walk(obj) {
    const keys = Object.keys(obj)
    for (let i = 0; i < keys.length; i++) {
      defineReactive(obj, keys[i])
    }
  }

  // 数组 时遍历处理
  observeArray(items) {
    for (let i = 0, l = items.length; i < l; i++) {
      observe(items[i])
    }
  }
}
```

数据劫持，包装 `set` 方法，监听数据更新 `defineReactive`

> 这里提一嘴 Object.defineProperty 方法，由于Object.defineProperty不能够监听数组下标，所以这里Vue其实是把数组的原有方法进行了重写，比如push，pop，先执行原逻辑函数，如果是往数组新增元素，则把新增元素变成响应式。

```js
function defineReactive(obj, key, val) {
  const dep = new Dep()

  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter() {
      return val
    },
    set: function reactiveSetter(newVal) {
      // ...
      // 数据变更 ==> 触发set方法 ==> 调用dep.notify()通知更新
      dep.notify()
    },
  })
}
```

被观察列表类 `Dep`

```js
class Dep {
  constructor() {
    this.id = uid++
    this.subs = []
  }

  addSub(sub) {
    // sub ===> Watcher
    this.subs.push(sub)
  }

  removeSub(sub) {
    // sub ===> Watcher
    remove(this.subs, sub)
  }

  notify() {
    // subs
    const subs = this.subs.slice()
    // update
    for (let i = 0, l = subs.length; i < l; i++) {
      subs[i].update()
    }
  }
}
```

### zustand 状态管理器

#### 先来看看用法

创建 store

```js
// store
import create from 'zustand'

// 通过 create 方法创建一个具有响应式的 store
const useStore = create(set => ({
  bears: 0,
  increasePopulation: () => set(state => ({ bears: state.bears + 1 })),
  removeAllBears: () => set({ bears: 0 })
}))
```

组件引用

```js
// UI 组件，展示 bears 状态，可被动更新
function BearCounter() {
  const bears = useStore(state => state.bears)
  return <h1>{bears} around here ...</h1>
}

// 控制组件，通过 store 内部创建的 increasePopulation 方法执行点击事件，可触发数据和UI组件更新
function Controls() {
  const increasePopulation = useStore(state => state.increasePopulation)
  return <button onClick={increasePopulation}>one up</button>
}
```

结合官方示例，可以确定 `zustand` 内部对通过 `state` 绑定的组件，默认添加注册到了订阅者队列，此时该 `bears` 属性相当于一个被观察者，当 `bears` 状态变更后，通知所有订阅了该数属性的组件进行更新。（我们可以大致推测一下这个 **set** 方法）

#### 直接上代码

废话不多说，看代码，我们先按照创建 `store` 的逻辑分析：

即 `create` 接受一个函数（非函数情况暂时不研究），返回我们定义的状态和方法，且该函数是提供 `set` 方法供我们使用的，而这个 `set` 方法必定是可以触发更新通知的。

`create` 方法

```js
import { useReducer, useRef } from "react"

function create(createState) {
  // init state
  const api = typeof createState === "function" ? createImpl(createState) : createState
}
```

这里引入了一个 `createImpl` 方法，我们先看下这个方法对 `createState` 的处理和返回值。

```js
function createImpl(createState) {
  // 用于缓存上一次的 状态
  let state
  // 监听队列
  const listeners = new Set()

  const setState = (partial, replace) => {
    // 如果是 function 注入 state 并获取执行结果，否则直接取值
    // 例如：setCount: ()=> set(state=> ({state: state.count +1 })
    // 例如：setCount: ()=> set({count: 10})
    const nextState = typeof partial === "function" ? partial(state) : partial
    // 优化：判断状态是否变化了，再更新组件状态
    if (nextState !== state) {
      // 上一次状态
      const previousState = state
      // 当前状态最新状态
      state = replace ? nextState : Object.assign({}, state, nextState)
      // 通知队列中的每一个组件
      listeners.forEach((listener) => listener(state, previousState))
    }
  }

  // 获取 state
  const getState = () => state

  //
  const subscribeWithSelector = (listener, selector = getState, equalityFn = Object.is) => {
    let currentSlice = selector(state)
    function listenerToAdd() {
      const nextSlice = selector(state)
      if (!equalityFn(currentSlice, nextSlice)) {
        const previousSlice = currentSlice
        listener((currentSlice = nextSlice), previousSlice)
      }
    }
    listeners.add(listenerToAdd)
    // Unsubscribe
    return () => listeners.delete(listenerToAdd)
  }

  // 添加订阅 
  const subscribe = (listener, selector, equalityFn) => {
    if (selector || equalityFn) {
      return subscribeWithSelector(listener, selector, equalityFn)
    }
    listeners.add(listener)
    // Unsubscribe
    // 执行结果为删除该订阅者函数
    // 即：const unsubscribe= subscribe() = () => listeners.delete(listener)
    return () => listeners.delete(listener)
  }

  // 清除 订阅
  const destroy = () => listeners.clear()
  //
  const api = { setState, getState, subscribe, destroy }
  // 其对传入的 createState 函数注入了3个参数 setState, getState, api 
  // 使得在 create 创建 store时，可以在回调函数的参数里取用方法对数据进行处理
  // 如：create(set=> ({count: 0,setCount: ()=> set(state=> ({state: state.count +1 }))}))
  // 并调用然后返回 api = { setState, getState, subscribe, destroy } 属性方法
  state = createState(setState, getState, api)

  return api
}
```

然后我们再回来继续往下分析 `create` 方法

```js
import { useReducer, useRef } from "react"

function create(createState) {
  // init state
  const api = typeof createState === "function" ? createImpl(createState) : createState
  // 这里提供了一个 useStore 方法，返回暴露给外部，绑定组件使用
  const useStore = (selector = api.getState, equalityFn = Object.is) => {

  }

  // 把 api 合并到 useStore
  Object.assign(useStore, api)

  // 返回 useStore 方法
  return useStore
}
```

## 结语

观察者模式和发布订阅模式在实际项目中非常常见，很多优秀的第三方库也是借鉴了这两种设计模式的思想 —— 比如 `Vue`， `RxJS`，`Redux`，`zustand` 等

对于项目中一些逻辑的解耦或者解决一些异步的问题非常有帮助。可以毫不夸张的说：**发布订阅模式**/**观察者模式**可以解决大部分解耦问题。

总的来说，阅读学习一些优秀的库（包括一些它们内部封装的工具函数，有很多巧妙的设计和实现），这种源码学习对于我们自身成长与技术拓展是很有帮助的，很多时候我们会被大佬们的独特思路和设计所折服，而通过进一步理解掌握，我们完全可以吸收自用，在日后的实战项目中**大显身手**，岂不美哉！

## 参考

- [观察者模式 vs 发布-订阅模式](https://juejin.cn/post/6844903513009422343)
- [介绍下观察者模式和订阅-发布模式的区别，各自适用于什么场景](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/25)
- [观察者模式与发布订阅模式真的不同](https://juejin.cn/post/6844903842501378055)
- [发布订阅模式](https://juejin.cn/post/6844903928413306887)
- [深入发布订阅模式](https://www.clloz.com/programming/front-end/js/2020/10/18/observer-pub-sub-pattern/)
- [JavaScript设计模式之观察者模式](https://juejin.cn/post/6844903698154389517)
- [JS设计模式之观察者模式](https://zhuanlan.zhihu.com/p/357911263)
- [观察者模式（JavaScript实现）](https://juejin.cn/post/6844904134840156168)
- [vue](https://github.com/vuejs/vue)
- [zustand](https://github.com/pmndrs/zustand)
