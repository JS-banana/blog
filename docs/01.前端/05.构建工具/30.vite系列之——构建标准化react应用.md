---
title: vite系列之—构建标准化react应用
date: 2021-07-09 14:48:05
permalink: /pages/428be4/
categories:
  - 前端
tags:
  - 构建工具
---

> vite官网：<https://cn.vitejs.dev/>
>
> 本文链接：<https://ssscode.com/pages/428be4>

## 背景

之前公司项目采用的是`umi`脚手架一体化构建工具，得益于对`webpack`与各框架的集成和封装，使得快速上手的能力大大加强，但是随着项目的不断迭代与功能臃肿，依赖的库也是越来越多，目前最明显的感受就是每次启动与打包构建的时长，往往是好几分钟~，热更新有时也要耗费数秒，对于开发效率与体验影响很大。。。

<!-- more -->

之前尤大发布`vite1.0`时也了解了一点，就是一个字“快”，咳咳~，不过一直没仔细研究过，只知道核心是基于`esbuild`和`rollup`，目前`vite2.0`已经发布，完全作为一个独立的构建工具，对`react`等其他非`vue`框架有着很好的支持。最近也算忙里偷闲，算是稍微研究了一下基本知识。本篇文章记录我以`vite`构建`react`的过程及细节，后续会继续深入研究输出`vite`相关系列文章，敬请期待~

## 目标

我对项目的要求：

- 支持`Typescript`
- 支持`React`、`JSX`语法
- 支持`ES6`语法
- 支持`Eslint`、`Prettier`、`Pre-commit hook`
- 支持`Less module`
- 支持`HMR`快速热更新
- `Antd`按需引入与主题样式覆盖
- `Proxy`代理、`alias`别名
- 开发启动速度要够快，以秒计算
- 支持懒加载和`chunk`分割

## vite简单介绍

### 前置条件之一

浏览器原生支持 ES 模块。

### 特点

- 基于原生 `ES` 模块，即 `<script type="module" >`，做到快速加载
- 使用 `Esbuild` 预构建依赖 （本地开发环境）
- 使用 `Rollup` 打包代码（线上生产环境）
- `HMR` 是在原生 `ESM` 上执行的
- 利用对 `HTTP` 头信息的控制，优化缓存与重加载，高效率利用浏览器能力。
- 开箱即用，内置多种支持，如：`Typescript`支持、`JSX`支持、`CommonJS`和`UMD`兼容、`css`预处理器与`css modules`等

### vite对模块的分类

- **依赖**：
  - 在开发时不会变动的纯 `JavaScript`。（如第三方依赖antd、lodash等）
  - 在该场景采用具有优势的 Esbuild 处理。（大量模块的组件库、CommonJS格式的文件等）
- **源码**：
  - 通常包含一些并非直接是 JavaScript 的文件，需要转换，时常会被编辑。（JSX、CSS、Vue/React组件等）
  - 会根据路由拆分代码按需加载模块
  - Vite 以 原生 ESM 方式提供源码

### 概念

**预构建**：将有许多内部模块的 ESM 依赖关系转换为单个模块，以提高后续页面加载性能。简单来说就是尽量合并与减少请求。

**例如**：当我们引入的一个第三方模块依赖了大量其他模块时，在不合并请求的情况下，会请求上百次不等，造成网络拥塞影响性能，而通过预构建合并后只需要一个请求即可。（`lodash-es` [有超过个内置模块！](https://unpkg.com/browse/lodash-es/)当我们执行 `import { debounce } from 'lodash-es'` 时，浏览器同时发出 600 多个 `HTTP` 请求！通过预构建 `lodash-es` 成为一个模块，我们就只需要一个 `HTTP` 请求了！）

相较于传统的 `webpack` 构建工具，先打包构建所有的依赖和项目代码，然后再启动开发服务器。`Vite` 则利用浏览器对 `ESM` 的支持，先启动开发服务器，然后再根据代码执行按需加载剩下所需的对应模块。

因为缓存，在我们第二次启动时几乎可以做到秒开！非常的可怕~

### 官网图

官网图很清晰的描绘了区别：

![Bundle based dev server](https://cn.vitejs.dev/assets/bundler.37740380.png)

![Native ESM based dev server](https://cn.vitejs.dev/assets/esm.3070012d.png)

## 步骤

### 项目初始化

官方支持`React`模板预设有：`react`、`react-ts`，因为我需要`Typescript`，所以直接用这个模板，省事了~

```sh
# npm 6.x
npm init @vitejs/app my-react-app --template react-ts

# npm 7+, 需要额外的双横线：
npm init @vitejs/app my-react-app -- --template react-ts

# yarn
yarn create @vitejs/app my-react-app --template react-ts
```

### 引入react三件套

这里我使用的是 `pnpm` 包管理工具，不了解的可以查看[pnpm官方文档](https://pnpm.io/),鉴于`pnpm`的后发优势与诞生宗旨，相较于传统的`npm`、`yarn`工具都有很好的性能提升与使用体验，这里不做过多介绍，放两张图大家自行体会下~

![安装速度比较](https://p5.itc.cn/q_70/images03/20210303/ff264a5ec0c7455abfc252c1d5f9d854.png)

![对比yarn PnP](https://p8.itc.cn/q_70/images03/20210303/028b414b9b9a4bf09865ebaf4044d9b8.png)

#### 安装依赖

```sh
# pnpm
pnpm add react react-dom react-router-dom
# or npm
npm i react react-dom react-router-dom
```

#### 创建页面

在`src`目录下创建`pages`目录放置页面组件模块，然后我们简单写两个页面测试下：

```tsx
// pages/Home/index.tsx
import React from 'react';

const Home: React.FC = () => <div> Home </div>;

export default Home;

// pages/About/index.tsx
import React from 'react';

const About: React.FC = () => <div> About </div>;

export default About;
```

#### 修改文件App.tsx

```tsx
// App.tsx
import React, { Suspense } from 'react';
import { BrowserRouter as Router, Route, Switch } from 'react-router-dom';
import Home from './pages/Home'
import About from './pages/About'

const App = () => {
  return (
    <Suspense fallback={<span>loading</span>}>
      <Router>
        <Switch>
          <Route key="/home" path="/home" component={Home}></Route>
          <Route key="/about" path="/about" component={About}></Route>
        </Switch>
      </Router>
    </Suspense>
  );
};

export default App;
```

![vite-react-app-1](https://cdn.jsdelivr.net/gh/JS-banana/images/vuepress/vite-react-img-1.jpg)

![vite-react-app-2](https://cdn.jsdelivr.net/gh/JS-banana/images/vuepress/vite-react-img-2.jpg)

#### 配置路由/界面

新建`layouts`组件，主要用于区别渲染**登录注册页面**与**布局界面**:

`layouts/BasicLayout.tsx`、`layouts/UserLayout.tsx`

这里就不一一做展示了，详细代码见仓库，地址贴在下面了。

新建路由配置文件`router/index.ts`:

```tsx
const routes: IRoute[] = [
  {
    path: '/user',
    component: React.lazy(() => import('../layouts/UserLayout')),
    meta: {
      title: '用户路由',
    },
    redirect: '/user/login',
    children: [],
  },
  {
    path: '/',
    component: React.lazy(() => import('../layouts/BasicLayout')),
    meta: {
      title: '系统路由',
    },
    redirect: '/home',
    children: [
      {
        path: '/home',
        meta: {
          title: '首页',
          icon: 'home',
        },
        component: <Home />,
      },
      {
        path: '/about',
        meta: {
          title: '关于',
          icon: 'about',
        },
        component: <About />,
      },
    ],
  },
]

export default routes;
```

#### 创建store状态管理文件

自`react hooks`诞生后，大部分场景使用`hooks`与`props`进行状态管理基本可以满足多数需求，少部分全局应用信息与用户信息等需要全局状态管理的，这里我觉得也不需要完整引入一个`redux`、`mobx`等这种库。当然还要结合具体场景和公司技术栈确定，较大型和复杂的项目等视情况而定~

我这里使用了`zustand`做了简单配置，使用起来也是比较的简单，详情参见[官方文档](https://github.com/pmndrs/zustand)

```js
// 创建store
import create from 'zustand'

const useStore = create(set => ({
  bears: 0,
  increasePopulation: () => set(state => ({ bears: state.bears + 1 })),
  removeAllBears: () => set({ bears: 0 })
}))
```

```js
// 组件绑定
function BearCounter() {
  const bears = useStore(state => state.bears)
  return <h1>{bears} around here ...</h1>
}

function Controls() {
  const increasePopulation = useStore(state => state.increasePopulation)
  return <button onClick={increasePopulation}>one up</button>
}
```

### 引入Antd组件库并配置按需加载

这里就不废话了，直接展示如何在`vite`中配置`antd`的按需加载

首先我们安装一个插件：

`pnpm add vite-plugin-imp -D`

然后在`vite.config.ts`文件的`plugins`中添加配置`vitePluginImp`

这里我们顺势再引入一个`less-vars-to-js`包，`less-vars-to-js`可以`less`样式转化为`json`键值对的形式，当然你也可以直接在`modifyVars`属性后写`json`键值对。这样做的好处是可以把全局配置统一放到`config`文件进行管理，方便维护。

> 自定义覆盖主题色
>
> config/variables.less // @primary-color: '#ff7875';

```ts
import reactRefresh from '@vitejs/plugin-react-refresh';
import lessToJS from 'less-vars-to-js';
import path from 'path';
import { defineConfig } from 'vite';
import vitePluginImp from 'vite-plugin-imp';

const themeVariables = lessToJS(
  fs.readFileSync(path.resolve(__dirname, './config/variables.less'), 'utf8'),
);

export default defineConfig({
  base,
  plugins: [
    reactRefresh(),
    // 配置按需引入antd
    vitePluginImp({
      libList: [
        {
          libName: 'antd',
          style: (name) => `antd/es/${name}/style/index.less`,
        },
      ],
    }),
  ],
  css: {
    preprocessorOptions: {
      less: {
        // 支持内联 JavaScript，支持 less 内联 JS
        javascriptEnabled: true,
        // 重写 less 变量，定制样式
        modifyVars: themeVariables,
      },
    },
  }
})
```

### 环境变量

通过 `--mode` 注入配置参数以匹配测试/开发环境等。

我们修改下`package.json`文件:

```json
scripts: {
  "build:beta": "vite build --mode beta",
  "build:release": "vite build --mode release",
}
```

`node`环境下直接`process.argv`即可获取到，我们可以在`vite.config.ts`中打印信息查看

```ts
// vite.config.ts
const env = process.argv[process.argv.length - 1];
console.log('env：', env);
```

组件内可通过`import.meta.env`获取，我们可以在`Home/index.tsx`中打印信息查看

```jsx
// Home/index.tsx
import React from 'react'
import { Button } from 'antd'

const Home: React.FC = () => {
  console.log('import.meta.env', import.meta.env)
  return <div>
    <Button type='primary'>Home</Button>
  </div>
}
export default Home
```

### alias 别名设置

```ts
export default defineConfig({
    ...
  resolve: {
    alias: {
      '~': path.resolve(__dirname, './'), // 根路径
      '@': path.resolve(__dirname, 'src') // src 路径
    }
  }
  ...
})
```

### proxy代理配置

```ts
export default defineConfig({
    ...
    server: {
    port: 8080, // 开发环境启动的端口
    proxy: {
      '/api': {
        // 当遇到 /api 路径时，将其转换成 target 的值
        target: 'http://127.0.0.1:8080/api/',
        changeOrigin: true,
        rewrite: (path) => path.replace(/^\/api/, ''), // 将 /api 重写为空
      },
    }
  }
})
```

### Eslint配置

### Prettier配置

## 目录结构

## 项目地址

[vite2-react-ts-antd-eslint-prettier](https://github.com/JS-banana/vite2-react-ts-antd-eslint-Prettier)

## 参考

> <https://cn.vitejs.dev/>
>
> <https://zhuanlan.zhihu.com/p/358403100>
>
> <https://github.com/pmndrs/zustand>
