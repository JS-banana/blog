(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{541:function(t,e,a){"use strict";a.r(e);var v=a(43),_=Object(v.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"前言"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[t._v("#")]),t._v(" 前言")]),t._v(" "),a("p",[t._v("首先，要想由浅入深了解清楚不可变数据（immutable data），我们应先回答下这几个问题：")]),t._v(" "),a("p",[t._v("何为可变数据？何为不可变数据？数据的区别？和react的关系？纯函数？")]),t._v(" "),a("h3",{attrs:{id:"数据类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据类型"}},[t._v("#")]),t._v(" 数据类型")]),t._v(" "),a("p",[t._v("对于JavaScript而言，数据主要分为"),a("strong",[t._v("基本类型")]),t._v("和"),a("strong",[t._v("引用类型")]),t._v("这两大类。")]),t._v(" "),a("ul",[a("li",[t._v("7种原始类型："),a("code",[t._v("Number")]),t._v("、"),a("code",[t._v("String")]),t._v("、"),a("code",[t._v("Boolean")]),t._v("、"),a("code",[t._v("Null")]),t._v("、"),a("code",[t._v("Undefined")]),t._v("、"),a("code",[t._v("Symbol")]),t._v("、"),a("code",[t._v("BigInt")])]),t._v(" "),a("li",[t._v("Object引用类型："),a("code",[t._v("Array")]),t._v("、"),a("code",[t._v("Object")]),t._v("、"),a("code",[t._v("Date")]),t._v("等，几乎所有通过 "),a("code",[t._v("new")]),t._v(" 创建的，即构造函数类型")])]),t._v(" "),a("p",[t._v("基本类型不存在变化的特性，可以认为属于不可变数据。")]),t._v(" "),a("p",[t._v("JavaScript 中的对象一般是可变的（"),a("code",[t._v("Mutable")]),t._v("），因为使用了引用赋值，新的对象简单的引用了原始对象，改变新的对象将影响到原始对象。")]),t._v(" "),a("ul",[a("li",[t._v("这样做的好处是可以节约内存，但当应用复杂后，这就造成了非常大的隐患，"),a("code",[t._v("Mutable")]),t._v(" 带来的优点变得得不偿失。")]),t._v(" "),a("li",[t._v("为了解决这个问题，一般的做法是使用 shallowCopy（浅拷贝）或 deepCopy（深拷贝）来避免被修改，但这样做又造成了 CPU 和内存的浪费。")])]),t._v(" "),a("blockquote",[a("p",[t._v("JS数据类型的详细说明可见我的这篇文章"),a("a",{attrs:{href:"https://juejin.cn/post/7092225590102589470",target:"_blank",rel:"noopener noreferrer"}},[t._v("彻底搞懂JS类型、类型判断、类型转换"),a("OutboundLink")],1)])]),t._v(" "),a("p",[t._v("Immutable 可以很好地解决这些问题。")]),t._v(" "),a("h2",{attrs:{id:"什么是-immutable-data"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是-immutable-data"}},[t._v("#")]),t._v(" 什么是 Immutable Data")]),t._v(" "),a("p",[a("code",[t._v("Immutable Data")]),t._v(" 就是一旦创建，就不能再被更改的数据。")]),t._v(" "),a("ul",[a("li",[t._v("对 "),a("code",[t._v("Immutable")]),t._v(" 对象的任何修改或添加删除操作都会返回一个新的 "),a("code",[t._v("Immutable")]),t._v(" 对象。")]),t._v(" "),a("li",[a("code",[t._v("Immutable")]),t._v(" 实现的原理是 "),a("code",[t._v("Persistent Data Structure")]),t._v("（持久化数据结构），也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变。")]),t._v(" "),a("li",[t._v("同时为了避免 "),a("code",[t._v("deepCopy")]),t._v(" 把所有节点都复制一遍带来的性能损耗，"),a("code",[t._v("Immutable")]),t._v(" 使用了 "),a("code",[t._v("Structural Sharing")]),t._v("（结构共享），即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享。")])]),t._v(" "),a("h2",{attrs:{id:"第三方库分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第三方库分析"}},[t._v("#")]),t._v(" 第三方库分析")]),t._v(" "),a("p",[t._v("immer vs immutable")]),t._v(" "),a("h2",{attrs:{id:"和react的关系"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#和react的关系"}},[t._v("#")]),t._v(" 和react的关系")]),t._v(" "),a("h2",{attrs:{id:"资料"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#资料"}},[t._v("#")]),t._v(" 资料")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://github.com/camsong/blog/issues/3",target:"_blank",rel:"noopener noreferrer"}},[t._v("Immutable 详解及 React 中实践"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://juejin.cn/post/6844904023808540680",target:"_blank",rel:"noopener noreferrer"}},[t._v("关于React Hooks和Immutable性能优化的实践，我写了一本掘金小册"),a("OutboundLink")],1)])])])}),[],!1,null,null,null);e.default=_.exports}}]);