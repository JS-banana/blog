(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{520:function(v,t,_){"use strict";_.r(t);var e=_(43),r=Object(e.a)({},(function(){var v=this,t=v.$createElement,_=v._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("p",[v._v("众所周知，JS是单线程的，但是其在浏览器中的具体运行机制是怎样的呢？什么是微任务什么是宏任务呢？本篇文章我们从整体宏观层面进行梳理和分享。")]),v._v(" "),_("h2",{attrs:{id:"浏览器都包含哪些进程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#浏览器都包含哪些进程"}},[v._v("#")]),v._v(" 浏览器都包含哪些进程")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("Browser进程")]),v._v(" "),_("ul",[_("li",[v._v("浏览器的主进程（负责协调、主控），只有一个")]),v._v(" "),_("li",[v._v("主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。")])])]),v._v(" "),_("li",[_("strong",[v._v("GPU进程")]),v._v(" "),_("ul",[_("li",[v._v("最多一个，用于3D绘制等")]),v._v(" "),_("li",[v._v("GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。")])])]),v._v(" "),_("li",[_("strong",[v._v("渲染进程")]),v._v(" "),_("ul",[_("li",[v._v("浏览器内核，Renderer进程，内部是多线程的")]),v._v(" "),_("li",[v._v("核心任务是将"),_("code",[v._v("HTML")]),v._v("、"),_("code",[v._v("CSS")]),v._v(" 和 "),_("code",[v._v("JavaScript")]),v._v(" 转换为用户可以与之交互的页面，排版引擎"),_("strong",[v._v("Blink")]),v._v("和Javascript引擎"),_("strong",[v._v("V8")]),v._v("都是运行在该进程中，默认情况下，"),_("strong",[v._v("Chrome会为每个Tab标签创建一个渲染进程")]),v._v("。出于安全考虑，渲染进程都是运行在沙箱模式下。")])])]),v._v(" "),_("li",[_("strong",[v._v("网络进程")]),v._v(" "),_("ul",[_("li",[v._v("主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。")])])]),v._v(" "),_("li",[_("strong",[v._v("第三方插件进程")]),v._v(" "),_("ul",[_("li",[v._v("每种类型的插件对应一个进程，仅当使用该插件时才创建")]),v._v(" "),_("li",[v._v("主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。")])])])]),v._v(" "),_("blockquote",[_("p",[v._v("注：进程间的通信是通过"),_("code",[v._v("进程通信管道IPC")]),v._v("来传递")])]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/JS-banana/images/vuepress/browser-chrome.jpg",alt:"chrome"}})]),v._v(" "),_("h3",{attrs:{id:"渲染进程包含了哪些线程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#渲染进程包含了哪些线程"}},[v._v("#")]),v._v(" 渲染进程包含了哪些线程")]),v._v(" "),_("blockquote",[_("p",[v._v("🙋‍♂️敲黑板："),_("strong",[v._v("浏览器的"),_("em",[v._v("渲染进程")]),v._v("是多"),_("em",[v._v("线程")]),v._v("的")])])]),v._v(" "),_("p",[v._v("它们分别是：")]),v._v(" "),_("ul",[_("li",[v._v("GUI渲染线程")]),v._v(" "),_("li",[v._v("JS引擎线程（"),_("strong",[v._v("JS引擎是单线程的")]),v._v("）")]),v._v(" "),_("li",[v._v("事件触发线程")]),v._v(" "),_("li",[v._v("定时触发器线程")]),v._v(" "),_("li",[v._v("异步http请求线程")])]),v._v(" "),_("p",[v._v("需要说明的是：")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("GUI渲染线程与JS引擎线程是互斥的")]),v._v("（JS也是会改变布局和样式的，GUI渲染进程只会在JS执行之前或结束之后运行）")]),v._v(" "),_("li",[v._v("异步http请求线程：在 "),_("code",[v._v("XMLHttpRequest")]),v._v(" 连接后是通过浏览器新开一个线程请求， 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到 JavaScript 引擎的处理队列中等待处理。")])]),v._v(" "),_("h3",{attrs:{id:"worker线程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#worker线程"}},[v._v("#")]),v._v(" Worker线程")]),v._v(" "),_("ul",[_("li",[v._v("创建Worker时，JS引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM）")]),v._v(" "),_("li",[v._v("JS引擎线程与worker线程间通过特定的方式通信（"),_("code",[v._v("postMessage API")]),v._v("，需要通过序列化对象来与线程交互特定的数据）")])]),v._v(" "),_("h2",{attrs:{id:"浏览器渲染流程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#浏览器渲染流程"}},[v._v("#")]),v._v(" 浏览器渲染流程")]),v._v(" "),_("ol",[_("li",[v._v("解析html，建立"),_("strong",[v._v("dom树")])]),v._v(" "),_("li",[v._v("解析css，构建"),_("strong",[v._v("style树")]),v._v("（将CSS代码解析成树形的数据结构，然后结合DOM合并成"),_("strong",[v._v("render树")]),v._v("）")]),v._v(" "),_("li",[v._v("布局render树（"),_("code",[v._v("Layout")]),v._v("/"),_("code",[v._v("reflow")]),v._v("），负责各元素尺寸、位置的计算")]),v._v(" "),_("li",[v._v("绘制render树（"),_("code",[v._v("paint")]),v._v("），绘制页面像素信息")]),v._v(" "),_("li",[v._v("浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。")])]),v._v(" "),_("p",[v._v("渲染完毕后就是load事件了，之后就是自己的JS逻辑处理了")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/JS-banana/images/vuepress/js-render.png",alt:"render"}})]),v._v(" "),_("h3",{attrs:{id:"load事件与domcontentloaded"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#load事件与domcontentloaded"}},[v._v("#")]),v._v(" load事件与DOMContentLoaded")]),v._v(" "),_("ul",[_("li",[v._v("当 "),_("code",[v._v("DOMContentLoaded")]),v._v(" 事件触发时，仅当DOM加载完成，不包括样式表，图片(譬如如果有"),_("code",[v._v("async")]),v._v("加载的脚本就不一定完成)")]),v._v(" "),_("li",[v._v("当 "),_("code",[v._v("onload")]),v._v(" 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了（渲染完毕了）")])]),v._v(" "),_("p",[v._v("所以，顺序是："),_("code",[v._v("DOMContentLoaded")]),v._v(" -> "),_("code",[v._v("load")])]),v._v(" "),_("h3",{attrs:{id:"css加载"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#css加载"}},[v._v("#")]),v._v(" CSS加载")]),v._v(" "),_("p",[v._v("css是由单独的下载线程异步下载的。")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("css加载不会阻塞DOM树解析")]),v._v("（异步加载时DOM照常构建）")]),v._v(" "),_("li",[_("strong",[v._v("但会阻塞render树渲染")]),v._v("（渲染时需等css加载完毕，因为render树需要css信息）")])]),v._v(" "),_("h2",{attrs:{id:"event-loop"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#event-loop"}},[v._v("#")]),v._v(" Event Loop")]),v._v(" "),_("ul",[_("li",[v._v("JS分为"),_("strong",[v._v("同步任务")]),v._v("和"),_("strong",[v._v("异步任务")])]),v._v(" "),_("li",[v._v("同步任务都在主线程上执行，形成一个"),_("strong",[v._v("执行栈")])]),v._v(" "),_("li",[v._v("主线程之外，"),_("strong",[v._v("事件触发线程")]),v._v("管理着一个"),_("strong",[v._v("任务队列")]),v._v("，栈中的代码执行完毕，就会读取事件队列中的事件，去执行那些回调\n"),_("ul",[_("li",[v._v("如点击事件会放入事件队列中🤡，当点击事件触发的时候才会放入JS引擎执行栈后面等待执行；")]),v._v(" "),_("li",[v._v("AJax异步同理，在执行请求时，会在事件队列中添加事件，ajax请求完毕后，执行栈为空时就会读取事件队列中的事件，执行回调")])])]),v._v(" "),_("li",[v._v("一旦执行栈中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈中，开始执行")])]),v._v(" "),_("blockquote",[_("p",[v._v("延伸："),_("code",[v._v("setTimeout")]),v._v("不能准时执行原因 => 因为主线程可能不为空闲（主线程运行时间不固定）")])]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/JS-banana/images/vuepress/js-render-1.png",alt:"Event Loop"}})]),v._v(" "),_("h3",{attrs:{id:"定时器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#定时器"}},[v._v("#")]),v._v(" 定时器")]),v._v(" "),_("p",[v._v("由专门的定时器线程控制")]),v._v(" "),_("p",[v._v("当使用"),_("code",[v._v("setTimeout")]),v._v("或"),_("code",[v._v("setInterval")]),v._v("时，它需要定时器线程计时，计时完成后就会将特定的事件推入事件队列中。")]),v._v(" "),_("h3",{attrs:{id:"settimeout模拟setinterval"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#settimeout模拟setinterval"}},[v._v("#")]),v._v(" setTimeout模拟setInterval")]),v._v(" "),_("p",[v._v("最佳实践是：用"),_("code",[v._v("setTimeout")]),v._v("模拟"),_("code",[v._v("setInterval")]),v._v("，或者特殊场合直接用"),_("code",[v._v("requestAnimationFrame")])]),v._v(" "),_("blockquote",[_("p",[v._v("setInterval是每次都精确的隔一段时间推入一个事件，但是，事件的实际执行时间不一定就准确，还有可能是这个事件还没执行完毕，下一个事件就来了")]),v._v(" "),_("p",[v._v("累计效应（上面提到的），如果setInterval代码在（setInterval）再次添加到队列之前还没有完成执行，就会导致定时器代码连续运行好几次，而之间没有间隔。")])]),v._v(" "),_("h2",{attrs:{id:"宏任务-微任务"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#宏任务-微任务"}},[v._v("#")]),v._v(" 宏任务/微任务")]),v._v(" "),_("h3",{attrs:{id:"macrotask（又称之为宏任务）"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#macrotask（又称之为宏任务）"}},[v._v("#")]),v._v(" macrotask（又称之为宏任务）")]),v._v(" "),_("p",[v._v("每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）")]),v._v(" "),_("ul",[_("li",[v._v("每一个task会从头到尾将这个任务执行完毕，不会执行其它")]),v._v(" "),_("li",[_("strong",[v._v("浏览器为了能够使得JS内部task与DOM任务能够有序的执行，会在一个task执行结束后，在下一个 task 执行开始前，对页面进行重新渲染")])])]),v._v(" "),_("blockquote",[_("p",[v._v("🙋‍♂️敲黑板啦："),_("code",[v._v("task->渲染->task->...")])])]),v._v(" "),_("h3",{attrs:{id:"microtask（又称为微任务）"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#microtask（又称为微任务）"}},[v._v("#")]),v._v(" microtask（又称为微任务）")]),v._v(" "),_("p",[v._v("在当前 task 执行结束后立即执行的任务（在渲染之前）")]),v._v(" "),_("blockquote",[_("p",[v._v("🙋敲黑板啦："),_("code",[v._v("宏任务 -> 微任务 -> 渲染 -> 下一个任务...")])])]),v._v(" "),_("hr"),v._v(" "),_("h2",{attrs:{id:"运行机制总结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#运行机制总结"}},[v._v("#")]),v._v(" 运行机制总结")]),v._v(" "),_("ul",[_("li",[v._v("执行一个宏任务（栈中没有就从"),_("strong",[v._v("事件队列")]),v._v("中获取）")]),v._v(" "),_("li",[v._v("执行过程中如果遇到微任务，就将它添加到微任务的任务队列中")]),v._v(" "),_("li",[v._v("宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）")]),v._v(" "),_("li",[v._v("当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染")]),v._v(" "),_("li",[v._v("渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）")])]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/JS-banana/images/vuepress/js-render-2.png",alt:"宏任务/微任务"}})]),v._v(" "),_("h2",{attrs:{id:"资料"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#资料"}},[v._v("#")]),v._v(" 资料")]),v._v(" "),_("ul",[_("li",[_("a",{attrs:{href:"https://segmentfault.com/a/1190000012925872",target:"_blank",rel:"noopener noreferrer"}},[v._v("最全JS运行机制"),_("OutboundLink")],1)]),v._v(" "),_("li",[_("a",{attrs:{href:"https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/",target:"_blank",rel:"noopener noreferrer"}},[v._v("宏/微任务事件循环"),_("OutboundLink")],1)]),v._v(" "),_("li",[_("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/362120843",target:"_blank",rel:"noopener noreferrer"}},[v._v("全面了解「Chrome」的多进程架构"),_("OutboundLink")],1)])])])}),[],!1,null,null,null);t.default=r.exports}}]);